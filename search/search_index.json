{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BrickFlow \u00b6 BrickFlow is a CLI tool for development and deployment of Python based Databricks Workflows in a declarative way. Concept \u00b6 brickflow aims to improve development experience for building any pipelines on databricks via: Providing a declarative way to describe workflows via decorators Provide intelligent defaults to compute targets Provide a code and git first approach to managing and deploying workflows Use IAC such as terraform to manage the state and deploy jobs and their infrastructure. CLI tool helps facilitate setting up a projects Provides additional functionality through the context library to be able to do additional things for workflows. Limitations & Missing Features in the Project \u00b6 Docs (WIP) Notebook Tasks Serverless Sql Tasks DLT Pipeline Tasks Support for Job Clusters Support for Look Up Clusters (given a cluster name auto fetch the id) Support for Warehouses Support for using existing warehouses CLI for initializing repo to setup entry points and required files CLI for visualizing workflow locally using a graphing tool Legal Information \u00b6 Support notice This software is provided as-is and is not officially supported by Sriharsha Tikkireddy nor Databricks through customer technical support channels. Support, questions, and feature requests can be communicated through the Issues page of the repo . Please understand that issues with the use of this code will not be answered or investigated by Databricks Support. Feedback \u00b6 Issues with brickflow ? Found a bug? Have a great idea for an addition? Want to improve the documentation? Please feel free to file an issue . Contributing \u00b6 To contribute please fork and create a pull request.","title":"Home"},{"location":"#brickflow","text":"BrickFlow is a CLI tool for development and deployment of Python based Databricks Workflows in a declarative way.","title":"BrickFlow"},{"location":"#concept","text":"brickflow aims to improve development experience for building any pipelines on databricks via: Providing a declarative way to describe workflows via decorators Provide intelligent defaults to compute targets Provide a code and git first approach to managing and deploying workflows Use IAC such as terraform to manage the state and deploy jobs and their infrastructure. CLI tool helps facilitate setting up a projects Provides additional functionality through the context library to be able to do additional things for workflows.","title":"Concept"},{"location":"#limitations-missing-features-in-the-project","text":"Docs (WIP) Notebook Tasks Serverless Sql Tasks DLT Pipeline Tasks Support for Job Clusters Support for Look Up Clusters (given a cluster name auto fetch the id) Support for Warehouses Support for using existing warehouses CLI for initializing repo to setup entry points and required files CLI for visualizing workflow locally using a graphing tool","title":"Limitations &amp; Missing Features in the Project"},{"location":"#legal-information","text":"Support notice This software is provided as-is and is not officially supported by Sriharsha Tikkireddy nor Databricks through customer technical support channels. Support, questions, and feature requests can be communicated through the Issues page of the repo . Please understand that issues with the use of this code will not be answered or investigated by Databricks Support.","title":"Legal Information"},{"location":"#feedback","text":"Issues with brickflow ? Found a bug? Have a great idea for an addition? Want to improve the documentation? Please feel free to file an issue .","title":"Feedback"},{"location":"#contributing","text":"To contribute please fork and create a pull request.","title":"Contributing"},{"location":"api/cli/","text":"Classes \u00b6 brickflow.cli.CdktfCmd \u00b6 Bases: click . Group Functions \u00b6 get_command ( ctx : click . Context , cmd_name : str ) -> Optional [ click . Command ] \u00b6 Source code in brickflow/cli/__init__.py 49 50 51 52 53 54 55 56 57 58 def get_command ( self , ctx : click . Context , cmd_name : str ) -> Optional [ click . Command ]: if cmd_name == \"cdktf\" : return cdktf_command () elif cmd_name in [ \"deploy\" , \"diff\" ]: return cdktf_command ( cmd_name ) else : rv = click . Group . get_command ( self , ctx , cmd_name ) if rv is not None : return rv raise ctx . fail ( f \"No such command ' { cmd_name } '.\" ) Functions \u00b6 brickflow . cli . cdktf () -> None \u00b6 CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 110 111 112 113 114 115 @cli . command def cdktf () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover brickflow . cli . cdktf_command ( base_command : Optional [ str ] = None ) -> click . Command \u00b6 Source code in brickflow/cli/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def cdktf_command ( base_command : Optional [ str ] = None ) -> click . Command : @click . command ( name = \"cdktf_cmd\" , short_help = \"CLI for deploying workflow projects.\" , context_settings = { \"ignore_unknown_options\" : True }, add_help_option = False , ) @click . argument ( \"args\" , nargs =- 1 ) def cmd ( args : Tuple [ str ]) -> None : # check to make sure you are in project root and then set python path to whole dir _check_git_dir () os . environ [ \"PYTHONPATH\" ] = os . getcwd () my_env = os . environ . copy () try : _args = list ( args ) # add a base command if its provided for proxying for brickflow deploy if base_command is not None : _args = [ base_command ] + _args subprocess . run ([ \"cdktf\" , * _args ], check = True , env = my_env ) except subprocess . CalledProcessError as e : raise ClickException ( str ( e )) return cmd brickflow . cli . cli () -> None \u00b6 CLI for managing Databricks Workflows Source code in brickflow/cli/__init__.py 61 62 63 64 @click . group ( invoke_without_command = True , no_args_is_help = True , cls = CdktfCmd ) @click . version_option ( prog_name = \"brickflow\" ) def cli () -> None : \"\"\"CLI for managing Databricks Workflows\"\"\" brickflow . cli . deploy () -> None \u00b6 CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 118 119 120 121 122 123 @cli . command def deploy () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover brickflow . cli . diff () -> None \u00b6 CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 126 127 128 129 130 131 @cli . command def diff () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover brickflow . cli . docs () -> None \u00b6 Use to open docs in your browser... Source code in brickflow/cli/__init__.py 102 103 104 105 106 107 @cli . command def docs () -> None : \"\"\"Use to open docs in your browser...\"\"\" docs_site = \"https://stikkireddy.github.io/brickflow/\" webbrowser . open ( docs_site , new = 2 ) click . echo ( f \"Opening browser for docs... site: { docs_site } \" ) brickflow . cli . init ( project_name : str , git_provider : str , workflows_dir : str ) -> None \u00b6 Initialize your project with Brickflows... Source code in brickflow/cli/__init__.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @cli . command @click . option ( \"-n\" , \"--project-name\" , type = str , prompt = True ) @click . option ( \"-p\" , \"--git-provider\" , type = click . Choice ([ \"github\" , \"gitlab\" ]), prompt = True ) @click . option ( \"-w\" , \"--workflows-dir\" , type = click . Path ( exists = True , file_okay = False ), prompt = True ) def init ( project_name : str , git_provider : str , workflows_dir : str ) -> None : \"\"\"Initialize your project with Brickflows...\"\"\" try : _check_git_dir () if _gitignore_exists () is False : raise GitIgnoreNotFoundError git_https_url : str = get_git_remote_url_https () or \"\" _update_gitignore () create_entry_point ( workflows_dir , render_template ( project_name = project_name , git_provider = git_provider , git_https_url = git_https_url , pkg = _validate_package ( workflows_dir ), ), ) except GitNotFoundError : raise ClickException ( \"Please make sure you are in the root directory of your project with git initialized.\" ) except GitIgnoreNotFoundError : raise ClickException ( \"Please make sure you create a .gitignore file in the root directory.\" )","title":"CLI"},{"location":"api/cli/#brickflow.cli-classes","text":"","title":"Classes"},{"location":"api/cli/#brickflow.cli.CdktfCmd","text":"Bases: click . Group","title":"CdktfCmd"},{"location":"api/cli/#brickflow.cli.CdktfCmd-functions","text":"","title":"Functions"},{"location":"api/cli/#brickflow.cli.CdktfCmd.get_command","text":"Source code in brickflow/cli/__init__.py 49 50 51 52 53 54 55 56 57 58 def get_command ( self , ctx : click . Context , cmd_name : str ) -> Optional [ click . Command ]: if cmd_name == \"cdktf\" : return cdktf_command () elif cmd_name in [ \"deploy\" , \"diff\" ]: return cdktf_command ( cmd_name ) else : rv = click . Group . get_command ( self , ctx , cmd_name ) if rv is not None : return rv raise ctx . fail ( f \"No such command ' { cmd_name } '.\" )","title":"get_command()"},{"location":"api/cli/#brickflow.cli-functions","text":"","title":"Functions"},{"location":"api/cli/#brickflow.cli.cdktf","text":"CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 110 111 112 113 114 115 @cli . command def cdktf () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover","title":"cdktf()"},{"location":"api/cli/#brickflow.cli.cdktf_command","text":"Source code in brickflow/cli/__init__.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def cdktf_command ( base_command : Optional [ str ] = None ) -> click . Command : @click . command ( name = \"cdktf_cmd\" , short_help = \"CLI for deploying workflow projects.\" , context_settings = { \"ignore_unknown_options\" : True }, add_help_option = False , ) @click . argument ( \"args\" , nargs =- 1 ) def cmd ( args : Tuple [ str ]) -> None : # check to make sure you are in project root and then set python path to whole dir _check_git_dir () os . environ [ \"PYTHONPATH\" ] = os . getcwd () my_env = os . environ . copy () try : _args = list ( args ) # add a base command if its provided for proxying for brickflow deploy if base_command is not None : _args = [ base_command ] + _args subprocess . run ([ \"cdktf\" , * _args ], check = True , env = my_env ) except subprocess . CalledProcessError as e : raise ClickException ( str ( e )) return cmd","title":"cdktf_command()"},{"location":"api/cli/#brickflow.cli.cli","text":"CLI for managing Databricks Workflows Source code in brickflow/cli/__init__.py 61 62 63 64 @click . group ( invoke_without_command = True , no_args_is_help = True , cls = CdktfCmd ) @click . version_option ( prog_name = \"brickflow\" ) def cli () -> None : \"\"\"CLI for managing Databricks Workflows\"\"\"","title":"cli()"},{"location":"api/cli/#brickflow.cli.deploy","text":"CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 118 119 120 121 122 123 @cli . command def deploy () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover","title":"deploy()"},{"location":"api/cli/#brickflow.cli.diff","text":"CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 126 127 128 129 130 131 @cli . command def diff () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover","title":"diff()"},{"location":"api/cli/#brickflow.cli.docs","text":"Use to open docs in your browser... Source code in brickflow/cli/__init__.py 102 103 104 105 106 107 @cli . command def docs () -> None : \"\"\"Use to open docs in your browser...\"\"\" docs_site = \"https://stikkireddy.github.io/brickflow/\" webbrowser . open ( docs_site , new = 2 ) click . echo ( f \"Opening browser for docs... site: { docs_site } \" )","title":"docs()"},{"location":"api/cli/#brickflow.cli.init","text":"Initialize your project with Brickflows... Source code in brickflow/cli/__init__.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @cli . command @click . option ( \"-n\" , \"--project-name\" , type = str , prompt = True ) @click . option ( \"-p\" , \"--git-provider\" , type = click . Choice ([ \"github\" , \"gitlab\" ]), prompt = True ) @click . option ( \"-w\" , \"--workflows-dir\" , type = click . Path ( exists = True , file_okay = False ), prompt = True ) def init ( project_name : str , git_provider : str , workflows_dir : str ) -> None : \"\"\"Initialize your project with Brickflows...\"\"\" try : _check_git_dir () if _gitignore_exists () is False : raise GitIgnoreNotFoundError git_https_url : str = get_git_remote_url_https () or \"\" _update_gitignore () create_entry_point ( workflows_dir , render_template ( project_name = project_name , git_provider = git_provider , git_https_url = git_https_url , pkg = _validate_package ( workflows_dir ), ), ) except GitNotFoundError : raise ClickException ( \"Please make sure you are in the root directory of your project with git initialized.\" ) except GitIgnoreNotFoundError : raise ClickException ( \"Please make sure you create a .gitignore file in the root directory.\" )","title":"init()"},{"location":"api/compute/","text":"","title":"Compute"},{"location":"api/context/","text":"Attributes \u00b6 brickflow . context . ctx = Context () module-attribute \u00b6 Classes \u00b6 brickflow . context . Context () -> None \u00b6 Source code in brickflow/context/context.py 145 146 147 148 149 150 151 152 def __init__ ( self ) -> None : # Order of init matters todo: fix this self . _dbutils : Optional [ Any ] = None self . _spark : Optional [ Any ] = None self . _task_coms : BrickflowTaskComs self . _current_task : Optional [ str ] = None self . _configure () Functions \u00b6 current_task () -> Optional [ str ] property \u00b6 Source code in brickflow/context/context.py 165 166 167 @property def current_task ( self ) -> Optional [ str ]: return self . _current_task dbutils () -> DBUtils property \u00b6 Source code in brickflow/context/context.py 230 231 232 @property def dbutils ( self ) -> \"DBUtils\" : # type: ignore # noqa return self . _dbutils dbutils_widget_get_or_else ( key : str , debug : Optional [ str ]) -> Optional [ str ] \u00b6 Source code in brickflow/context/context.py 238 239 240 241 242 243 244 245 def dbutils_widget_get_or_else ( self , key : str , debug : Optional [ str ] ) -> Optional [ str ]: try : return self . dbutils . widgets . get ( key ) except Exception : # todo: log error return debug get_return_value ( task_key : Union [ str , Callable ]) -> Any \u00b6 Source code in brickflow/context/context.py 175 176 177 def get_return_value ( self , task_key : Union [ str , Callable ]) -> Any : task_key = task_key . __name__ if callable ( task_key ) else task_key return self . task_coms . get ( task_key , RETURN_VALUE_KEY ) job_id ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 210 211 212 @bind_variable ( BrickflowBuiltInTaskVariables . job_id ) def job_id ( self , * , debug : Optional [ str ]) -> str : pass log () -> logging . Logger property \u00b6 Source code in brickflow/context/context.py 226 227 228 @property def log ( self ) -> logging . Logger : return log parent_run_id ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 214 215 216 @bind_variable ( BrickflowBuiltInTaskVariables . parent_run_id ) def parent_run_id ( self , * , debug : Optional [ str ]) -> str : pass run_id ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 206 207 208 @bind_variable ( BrickflowBuiltInTaskVariables . run_id ) def run_id ( self , * , debug : Optional [ str ]) -> str : pass skip_all_except ( branch_task : Union [ Callable , str ]) -> None \u00b6 Source code in brickflow/context/context.py 179 180 181 182 183 184 185 186 187 def skip_all_except ( self , branch_task : Union [ Callable , str ]) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) branch_task_key = ( branch_task . __name__ if callable ( branch_task ) and hasattr ( branch_task , \"__name__\" ) is True else branch_task ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , branch_task_key ) skip_all_following () -> None \u00b6 Source code in brickflow/context/context.py 189 190 191 192 def skip_all_following ( self ) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK ) spark () -> SparkSession property \u00b6 Source code in brickflow/context/context.py 234 235 236 @property def spark ( self ) -> \"SparkSession\" : # type: ignore # noqa return self . _spark start_date ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 218 219 220 @bind_variable ( BrickflowBuiltInTaskVariables . start_date ) def start_date ( self , * , debug : Optional [ str ]) -> str : pass start_time ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 222 223 224 @bind_variable ( BrickflowBuiltInTaskVariables . start_time ) def start_time ( self , * , debug : Optional [ str ]) -> str : pass task_coms () -> BrickflowTaskComs property \u00b6 Source code in brickflow/context/context.py 194 195 196 @property def task_coms ( self ) -> BrickflowTaskComs : return self . _task_coms task_key ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 198 199 200 @bind_variable ( BrickflowBuiltInTaskVariables . task_key ) def task_key ( self , * , debug : Optional [ str ]) -> str : pass task_retry_count ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 202 203 204 @bind_variable ( BrickflowBuiltInTaskVariables . task_retry_count ) def task_retry_count ( self , * , debug : Optional [ str ]) -> str : pass","title":"Context"},{"location":"api/context/#brickflow.context-attributes","text":"","title":"Attributes"},{"location":"api/context/#brickflow.context.ctx","text":"","title":"ctx"},{"location":"api/context/#brickflow.context-classes","text":"","title":"Classes"},{"location":"api/context/#brickflow.context.Context","text":"Source code in brickflow/context/context.py 145 146 147 148 149 150 151 152 def __init__ ( self ) -> None : # Order of init matters todo: fix this self . _dbutils : Optional [ Any ] = None self . _spark : Optional [ Any ] = None self . _task_coms : BrickflowTaskComs self . _current_task : Optional [ str ] = None self . _configure ()","title":"Context"},{"location":"api/context/#brickflow.context.Context-functions","text":"","title":"Functions"},{"location":"api/context/#brickflow.context.context.Context.current_task","text":"Source code in brickflow/context/context.py 165 166 167 @property def current_task ( self ) -> Optional [ str ]: return self . _current_task","title":"current_task()"},{"location":"api/context/#brickflow.context.context.Context.dbutils","text":"Source code in brickflow/context/context.py 230 231 232 @property def dbutils ( self ) -> \"DBUtils\" : # type: ignore # noqa return self . _dbutils","title":"dbutils()"},{"location":"api/context/#brickflow.context.context.Context.dbutils_widget_get_or_else","text":"Source code in brickflow/context/context.py 238 239 240 241 242 243 244 245 def dbutils_widget_get_or_else ( self , key : str , debug : Optional [ str ] ) -> Optional [ str ]: try : return self . dbutils . widgets . get ( key ) except Exception : # todo: log error return debug","title":"dbutils_widget_get_or_else()"},{"location":"api/context/#brickflow.context.context.Context.get_return_value","text":"Source code in brickflow/context/context.py 175 176 177 def get_return_value ( self , task_key : Union [ str , Callable ]) -> Any : task_key = task_key . __name__ if callable ( task_key ) else task_key return self . task_coms . get ( task_key , RETURN_VALUE_KEY )","title":"get_return_value()"},{"location":"api/context/#brickflow.context.context.Context.job_id","text":"Source code in brickflow/context/context.py 210 211 212 @bind_variable ( BrickflowBuiltInTaskVariables . job_id ) def job_id ( self , * , debug : Optional [ str ]) -> str : pass","title":"job_id()"},{"location":"api/context/#brickflow.context.context.Context.log","text":"Source code in brickflow/context/context.py 226 227 228 @property def log ( self ) -> logging . Logger : return log","title":"log()"},{"location":"api/context/#brickflow.context.context.Context.parent_run_id","text":"Source code in brickflow/context/context.py 214 215 216 @bind_variable ( BrickflowBuiltInTaskVariables . parent_run_id ) def parent_run_id ( self , * , debug : Optional [ str ]) -> str : pass","title":"parent_run_id()"},{"location":"api/context/#brickflow.context.context.Context.run_id","text":"Source code in brickflow/context/context.py 206 207 208 @bind_variable ( BrickflowBuiltInTaskVariables . run_id ) def run_id ( self , * , debug : Optional [ str ]) -> str : pass","title":"run_id()"},{"location":"api/context/#brickflow.context.context.Context.skip_all_except","text":"Source code in brickflow/context/context.py 179 180 181 182 183 184 185 186 187 def skip_all_except ( self , branch_task : Union [ Callable , str ]) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) branch_task_key = ( branch_task . __name__ if callable ( branch_task ) and hasattr ( branch_task , \"__name__\" ) is True else branch_task ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , branch_task_key )","title":"skip_all_except()"},{"location":"api/context/#brickflow.context.context.Context.skip_all_following","text":"Source code in brickflow/context/context.py 189 190 191 192 def skip_all_following ( self ) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK )","title":"skip_all_following()"},{"location":"api/context/#brickflow.context.context.Context.spark","text":"Source code in brickflow/context/context.py 234 235 236 @property def spark ( self ) -> \"SparkSession\" : # type: ignore # noqa return self . _spark","title":"spark()"},{"location":"api/context/#brickflow.context.context.Context.start_date","text":"Source code in brickflow/context/context.py 218 219 220 @bind_variable ( BrickflowBuiltInTaskVariables . start_date ) def start_date ( self , * , debug : Optional [ str ]) -> str : pass","title":"start_date()"},{"location":"api/context/#brickflow.context.context.Context.start_time","text":"Source code in brickflow/context/context.py 222 223 224 @bind_variable ( BrickflowBuiltInTaskVariables . start_time ) def start_time ( self , * , debug : Optional [ str ]) -> str : pass","title":"start_time()"},{"location":"api/context/#brickflow.context.context.Context.task_coms","text":"Source code in brickflow/context/context.py 194 195 196 @property def task_coms ( self ) -> BrickflowTaskComs : return self . _task_coms","title":"task_coms()"},{"location":"api/context/#brickflow.context.context.Context.task_key","text":"Source code in brickflow/context/context.py 198 199 200 @bind_variable ( BrickflowBuiltInTaskVariables . task_key ) def task_key ( self , * , debug : Optional [ str ]) -> str : pass","title":"task_key()"},{"location":"api/context/#brickflow.context.context.Context.task_retry_count","text":"Source code in brickflow/context/context.py 202 203 204 @bind_variable ( BrickflowBuiltInTaskVariables . task_retry_count ) def task_retry_count ( self , * , debug : Optional [ str ]) -> str : pass","title":"task_retry_count()"},{"location":"api/misc/","text":"","title":"Misc"},{"location":"api/project/","text":"Classes \u00b6 brickflow.engine.project.Project dataclass \u00b6 Attributes \u00b6 batch : bool = True class-attribute \u00b6 debug_execute_task : Optional [ str ] = None class-attribute \u00b6 debug_execute_workflow : Optional [ str ] = None class-attribute \u00b6 entry_point_path : Optional [ str ] = None class-attribute \u00b6 git_reference : Optional [ str ] = None class-attribute \u00b6 git_repo : Optional [ str ] = None class-attribute \u00b6 libraries : Optional [ List [ TaskLibrary ]] = None class-attribute \u00b6 mode : Optional [ str ] = None class-attribute \u00b6 name : str class-attribute \u00b6 provider : Optional [ str ] = None class-attribute \u00b6 s3_backend : Optional [ str ] = None class-attribute \u00b6 Functions \u00b6 __enter__ () -> _Project \u00b6 Source code in brickflow/engine/project.py 255 256 257 258 259 260 261 262 263 264 265 def __enter__ ( self ) -> \"_Project\" : self . _project = _Project ( self . git_repo , self . provider , self . git_reference , self . s3_backend , self . entry_point_path , libraries = self . libraries or [], batch = self . batch , ) return self . _project __exit__ ( exc_type , exc_val , exc_tb ) -> None \u00b6 Source code in brickflow/engine/project.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def __exit__ ( self , exc_type , exc_val , exc_tb ) -> None : # type: ignore if exc_type is not None : raise exc_type if len ( self . _project . workflows ) == 0 : log . info ( \"Doing nothing no workflows...\" ) return if self . _mode . value == Stage . deploy . value : # local import to avoid node req from cdktf import App app = App () self . _project . generate_tf ( app , self . name , ) app . synth () if self . _mode . value == Stage . execute . value : wf_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . workflow_id . value , self . debug_execute_workflow , ) t_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . task_id . value , self . debug_execute_task ) if wf_id is None or t_id is None : log . info ( \"No workflow id or task key was able to found; doing nothing...\" ) return workflow = self . _project . get_workflow ( wf_id ) task = workflow . get_task ( t_id ) task . execute () __post_init__ () -> None \u00b6 Source code in brickflow/engine/project.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def __post_init__ ( self ) -> None : self . _mode = Stage [ config ( BrickflowEnvVars . BRICKFLOW_MODE . value , default = Stage . execute . value ) ] self . entry_point_path = self . entry_point_path or get_caller_info () if self . _mode == Stage . deploy : git_ref_default = ( self . git_reference if self . git_reference is not None else f \"commit/ { get_current_commit () } \" ) else : git_ref_default = ( self . git_reference if self . git_reference is not None else \"\" ) self . git_reference = config ( BrickflowEnvVars . BRICKFLOW_GIT_REF . value , default = git_ref_default ) self . provider = config ( BrickflowEnvVars . BRICKFLOW_GIT_PROVIDER . value , default = self . provider ) self . git_repo = config ( BrickflowEnvVars . BRICKFLOW_GIT_REPO . value , default = self . git_repo )","title":"Project"},{"location":"api/project/#brickflow.engine.project-classes","text":"","title":"Classes"},{"location":"api/project/#brickflow.engine.project.Project","text":"","title":"Project"},{"location":"api/project/#brickflow.engine.project.Project-attributes","text":"","title":"Attributes"},{"location":"api/project/#brickflow.engine.project.Project.batch","text":"","title":"batch"},{"location":"api/project/#brickflow.engine.project.Project.debug_execute_task","text":"","title":"debug_execute_task"},{"location":"api/project/#brickflow.engine.project.Project.debug_execute_workflow","text":"","title":"debug_execute_workflow"},{"location":"api/project/#brickflow.engine.project.Project.entry_point_path","text":"","title":"entry_point_path"},{"location":"api/project/#brickflow.engine.project.Project.git_reference","text":"","title":"git_reference"},{"location":"api/project/#brickflow.engine.project.Project.git_repo","text":"","title":"git_repo"},{"location":"api/project/#brickflow.engine.project.Project.libraries","text":"","title":"libraries"},{"location":"api/project/#brickflow.engine.project.Project.mode","text":"","title":"mode"},{"location":"api/project/#brickflow.engine.project.Project.name","text":"","title":"name"},{"location":"api/project/#brickflow.engine.project.Project.provider","text":"","title":"provider"},{"location":"api/project/#brickflow.engine.project.Project.s3_backend","text":"","title":"s3_backend"},{"location":"api/project/#brickflow.engine.project.Project-functions","text":"","title":"Functions"},{"location":"api/project/#brickflow.engine.project.Project.__enter__","text":"Source code in brickflow/engine/project.py 255 256 257 258 259 260 261 262 263 264 265 def __enter__ ( self ) -> \"_Project\" : self . _project = _Project ( self . git_repo , self . provider , self . git_reference , self . s3_backend , self . entry_point_path , libraries = self . libraries or [], batch = self . batch , ) return self . _project","title":"__enter__()"},{"location":"api/project/#brickflow.engine.project.Project.__exit__","text":"Source code in brickflow/engine/project.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def __exit__ ( self , exc_type , exc_val , exc_tb ) -> None : # type: ignore if exc_type is not None : raise exc_type if len ( self . _project . workflows ) == 0 : log . info ( \"Doing nothing no workflows...\" ) return if self . _mode . value == Stage . deploy . value : # local import to avoid node req from cdktf import App app = App () self . _project . generate_tf ( app , self . name , ) app . synth () if self . _mode . value == Stage . execute . value : wf_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . workflow_id . value , self . debug_execute_workflow , ) t_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . task_id . value , self . debug_execute_task ) if wf_id is None or t_id is None : log . info ( \"No workflow id or task key was able to found; doing nothing...\" ) return workflow = self . _project . get_workflow ( wf_id ) task = workflow . get_task ( t_id ) task . execute ()","title":"__exit__()"},{"location":"api/project/#brickflow.engine.project.Project.__post_init__","text":"Source code in brickflow/engine/project.py 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def __post_init__ ( self ) -> None : self . _mode = Stage [ config ( BrickflowEnvVars . BRICKFLOW_MODE . value , default = Stage . execute . value ) ] self . entry_point_path = self . entry_point_path or get_caller_info () if self . _mode == Stage . deploy : git_ref_default = ( self . git_reference if self . git_reference is not None else f \"commit/ { get_current_commit () } \" ) else : git_ref_default = ( self . git_reference if self . git_reference is not None else \"\" ) self . git_reference = config ( BrickflowEnvVars . BRICKFLOW_GIT_REF . value , default = git_ref_default ) self . provider = config ( BrickflowEnvVars . BRICKFLOW_GIT_PROVIDER . value , default = self . provider ) self . git_repo = config ( BrickflowEnvVars . BRICKFLOW_GIT_REPO . value , default = self . git_repo )","title":"__post_init__()"},{"location":"api/task/","text":"Classes \u00b6 brickflow.engine.task.Task dataclass \u00b6 Attributes \u00b6 cluster : Cluster class-attribute \u00b6 custom_execute_callback : Optional [ Callable ] = None class-attribute \u00b6 depends_on : List [ Union [ Callable , str ]] = field ( default_factory = lambda : []) class-attribute \u00b6 description : Optional [ str ] = None class-attribute \u00b6 libraries : List [ TaskLibrary ] = field ( default_factory = lambda : []) class-attribute \u00b6 task_func : Callable class-attribute \u00b6 task_id : str class-attribute \u00b6 task_settings : Optional [ TaskSettings ] = None class-attribute \u00b6 task_type : TaskType = TaskType . NOTEBOOK class-attribute \u00b6 trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS class-attribute \u00b6 workflow : Workflow class-attribute \u00b6 Functions \u00b6 brickflow_default_params () -> Dict [ str , str ] property \u00b6 Source code in brickflow/engine/task.py 308 309 310 311 312 313 314 315 @property def brickflow_default_params ( self ) -> Dict [ str , str ]: return { BrickflowInternalVariables . workflow_id . value : self . workflow . name , # 2 braces to escape 1 BrickflowInternalVariables . task_id . value : f \" {{{{ { BrickflowBuiltInTaskVariables . task_key . name } }}}} \" , BrickflowInternalVariables . only_run_tasks . value : \"\" , } builtin_notebook_params () -> Dict [ str , str ] property \u00b6 Source code in brickflow/engine/task.py 299 300 301 302 @property def builtin_notebook_params ( self ) -> Dict [ str , str ]: # 2 braces to escape for 1 return { i . value : f \" {{{{ { i . name } }}}} \" for i in BrickflowBuiltInTaskVariables } custom_task_parameters () -> Dict [ str , Union [ str , None , numbers . Number ]] property \u00b6 Source code in brickflow/engine/task.py 355 356 357 358 359 360 @property def custom_task_parameters ( self ) -> Dict [ str , Union [ str , None , numbers . Number ]]: spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) if spec . kwonlydefaults is None : return {} return { k : str ( v ) for k , v in spec . kwonlydefaults . items ()} depends_on_names () -> Iterator [ str ] property \u00b6 Source code in brickflow/engine/task.py 287 288 289 290 291 292 293 @property def depends_on_names ( self ) -> Iterator [ str ]: for i in self . depends_on : if callable ( i ) and hasattr ( i , \"__name__\" ): yield i . __name__ else : yield str ( i ) execute () -> Any \u00b6 Source code in brickflow/engine/task.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 @with_brickflow_logger def execute ( self ) -> Any : # Workflow is: # 1. Check to see if there selected tasks and if there are is this task in the list # 2. Check to see if the previous task is skipped and trigger rule. # 3. Check to see if this a custom python task and execute it # 4. Execute the task function ctx . _set_current_task ( self . name ) _select_task_skip , _select_task_skip_reason = self . _skip_because_not_selected () if _select_task_skip is True : # check if this task is skipped due to task selection logging . info ( \"Skipping task... %s for reason: %s \" , self . name , _select_task_skip_reason , ) ctx . _reset_current_task () return _skip , reason = self . should_skip () if _skip is True : logging . info ( \"Skipping task... %s for reason: %s \" , self . name , reason ) ctx . task_coms . put ( self . name , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK ) ctx . _reset_current_task () return return_value = TaskComsObjectResult . NO_RESULTS if ( self . task_type == TaskType . CUSTOM_PYTHON_TASK and self . custom_execute_callback is not None ): resp : CustomTaskResponse = self . custom_execute_callback ( self ) if resp . push_return_value is True : return_value = resp . response else : # TODO: Inject context object return_value = self . task_func () ctx . task_coms . put ( self . name , RETURN_VALUE_KEY , return_value ) ctx . _reset_current_task () return return_value get_tf_obj ( entrypoint ) -> JobTaskNotebookTask \u00b6 Source code in brickflow/engine/task.py 317 318 319 320 321 322 323 324 325 326 327 328 def get_tf_obj ( self , entrypoint ) -> \"JobTaskNotebookTask\" : # type: ignore # noqa from brickflow.tf.databricks import JobTaskNotebookTask if self . task_type in [ TaskType . NOTEBOOK , TaskType . CUSTOM_PYTHON_TASK ]: return JobTaskNotebookTask ( notebook_path = entrypoint , base_parameters = { ** self . builtin_notebook_params , ** self . brickflow_default_params , ** ( self . custom_task_parameters or {}), # type: ignore }, ) is_valid_task_signature () -> None \u00b6 Source code in brickflow/engine/task.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def is_valid_task_signature ( self ) -> None : # only supports kwonlyargs with defaults spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) sig : inspect . Signature = inspect . signature ( self . task_func ) signature_error_msg = ( \"Task signatures only supports kwargs with defaults. or catch all varkw **kwargs\" \"For example def execute(*, variable_a=None, variable_b=None, **kwargs). \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) kwargs_default_error_msg = ( f \"Keyword arguments must be either None, String or number. \" f \"Please handle booleans via strings. \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) valid_case = spec . args == [] and spec . varargs is None and spec . defaults is None for _ , v in ( spec . kwonlydefaults or {}) . items (): if not ( isinstance ( v , ( numbers . Number , str )) or v is None ): raise InvalidTaskSignatureDefinition ( kwargs_default_error_msg ) if valid_case : return raise InvalidTaskSignatureDefinition ( signature_error_msg ) name () -> str property \u00b6 Source code in brickflow/engine/task.py 304 305 306 @property def name ( self ) -> str : return self . task_id parents () -> List [ str ] property \u00b6 Source code in brickflow/engine/task.py 283 284 285 @property def parents ( self ) -> List [ str ]: return list ( self . workflow . parents ( self . task_id )) should_skip () -> Tuple [ bool , Optional [ str ]] \u00b6 Source code in brickflow/engine/task.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def should_skip ( self ) -> Tuple [ bool , Optional [ str ]]: # return true or false and reason node_skip_checks = [] for parent in self . parents : if parent != ROOT_NODE : try : task_to_not_skip = ctx . task_coms . get ( parent , BRANCH_SKIP_EXCEPT ) if self . name != task_to_not_skip : # set this task to skip hack to keep to empty to trigger failure # key look up will fail node_skip_checks . append ( True ) else : node_skip_checks . append ( False ) except Exception : # ignore errors as it probably doesnt exist # TODO: log errors node_skip_checks . append ( False ) if not node_skip_checks : return False , None if self . trigger_rule == BrickflowTriggerRule . NONE_FAILED : # by default a task failure automatically skips return self . _get_skip_with_reason ( all ( node_skip_checks ), \"At least one task before this were not successful\" , ) # default is BrickflowTriggerRule.ALL_SUCCESS return self . _get_skip_with_reason ( any ( node_skip_checks ), \"All tasks before this were not successful\" ) task_func_name () -> str property \u00b6 Source code in brickflow/engine/task.py 279 280 281 @property def task_func_name ( self ) -> str : return self . task_func . __name__ task_type_str () -> str property \u00b6 Source code in brickflow/engine/task.py 295 296 297 @property def task_type_str ( self ) -> str : return self . task_type . value brickflow.engine.task.EmailNotifications dataclass \u00b6 Attributes \u00b6 on_failure : Optional [ List [ str ]] = None class-attribute \u00b6 on_start : Optional [ List [ str ]] = None class-attribute \u00b6 on_success : Optional [ List [ str ]] = None class-attribute \u00b6 Functions \u00b6 to_tf_dict () -> Dict [ str , Optional [ List [ str ]]] \u00b6 Source code in brickflow/engine/task.py 205 206 207 208 209 210 def to_tf_dict ( self ) -> Dict [ str , Optional [ List [ str ]]]: return { \"on_start\" : self . on_start , \"on_failure\" : self . on_failure , \"on_success\" : self . on_success , } brickflow.engine.task.JarTaskLibrary dataclass \u00b6 Bases: StorageBasedTaskLibrary Parameters: Name Type Description Default jar str String to s3/dbfs path for jar required Attributes \u00b6 jar : str class-attribute \u00b6 brickflow.engine.task.EggTaskLibrary dataclass \u00b6 Bases: StorageBasedTaskLibrary Parameters: Name Type Description Default egg str String to s3/dbfs path for egg required Attributes \u00b6 egg : str class-attribute \u00b6 brickflow.engine.task.WheelTaskLibrary dataclass \u00b6 Bases: StorageBasedTaskLibrary Parameters: Name Type Description Default whl str String to s3/dbfs path for whl required Attributes \u00b6 whl : str class-attribute \u00b6 brickflow.engine.task.PypiTaskLibrary dataclass \u00b6 Bases: TaskLibrary Parameters: Name Type Description Default package str The package in pypi i.e. requests, requests==x.y.z, git+ https://github.com/stikkireddy/brickflow.git required repo Optional [ str ] The repository where the package can be found. By default pypi is used None Attributes \u00b6 package : str class-attribute \u00b6 repo : Optional [ str ] = None class-attribute \u00b6 Functions \u00b6 dict () -> Dict [ str , Union [ str , Dict [ str , str ]]] property \u00b6 Source code in brickflow/engine/task.py 157 158 159 @property def dict ( self ) -> Dict [ str , Union [ str , Dict [ str , str ]]]: return { \"pypi\" : dataclasses . asdict ( self )} brickflow.engine.task.MavenTaskLibrary dataclass \u00b6 Bases: TaskLibrary Parameters: Name Type Description Default coordinates str Gradle-style Maven coordinates. For example: org.jsoup:jsoup:1.7.2. required repo Optional [ str ] Maven repo to install the Maven package from. If omitted, both Maven Central Repository and Spark Packages are searched. None exclusions Optional [ List [ str ]] List of dependences to exclude. For example: [\"slf4j:slf4j\", \"*:hadoop-client\"]. Maven dependency exclusions: https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html . None Attributes \u00b6 coordinates : str class-attribute \u00b6 exclusions : Optional [ List [ str ]] = None class-attribute \u00b6 repo : Optional [ str ] = None class-attribute \u00b6 Functions \u00b6 dict () -> Dict [ str , Union [ str , Dict [ str , str ]]] property \u00b6 Source code in brickflow/engine/task.py 178 179 180 @property def dict ( self ) -> Dict [ str , Union [ str , Dict [ str , str ]]]: return { \"maven\" : dataclasses . asdict ( self )} brickflow.engine.task.CranTaskLibrary dataclass \u00b6 Bases: TaskLibrary Parameters: Name Type Description Default package str The name of the CRAN package to install. required repo Optional [ str ] The repository where the package can be found. If not specified, the default CRAN repo is used. None Attributes \u00b6 package : str class-attribute \u00b6 repo : Optional [ str ] = None class-attribute \u00b6 Functions \u00b6 dict () -> Dict [ str , Union [ str , Dict [ str , str ]]] property \u00b6 Source code in brickflow/engine/task.py 194 195 196 @property def dict ( self ) -> Dict [ str , Union [ str , Dict [ str , str ]]]: return { \"cran\" : dataclasses . asdict ( self )} brickflow.engine.task.BrickflowTriggerRule \u00b6 Bases: Enum Attributes \u00b6 ALL_SUCCESS = 'all_success' class-attribute \u00b6 NONE_FAILED = 'none_failed' class-attribute \u00b6 brickflow.engine.task.BrickflowTaskEnvVars \u00b6 Bases: Enum Attributes \u00b6 BRICKFLOW_SELECT_TASKS = 'BRICKFLOW_SELECT_TASKS' class-attribute \u00b6 brickflow.engine.task.TaskSettings dataclass \u00b6 Attributes \u00b6 email_notifications : Optional [ EmailNotifications ] = None class-attribute \u00b6 max_retries : Optional [ int ] = None class-attribute \u00b6 min_retry_interval_millis : Optional [ int ] = None class-attribute \u00b6 retry_on_timeout : Optional [ bool ] = None class-attribute \u00b6 timeout_seconds : Optional [ int ] = None class-attribute \u00b6 Functions \u00b6 merge ( other : Optional [ TaskSettings ]) -> TaskSettings \u00b6 Source code in brickflow/engine/task.py 221 222 223 224 225 226 227 228 229 230 231 def merge ( self , other : Optional [ \"TaskSettings\" ]) -> \"TaskSettings\" : # overrides top level values if other is None : return self return TaskSettings ( other . email_notifications or self . email_notifications , other . timeout_seconds or self . timeout_seconds or 0 , other . max_retries or self . max_retries , other . min_retry_interval_millis or self . min_retry_interval_millis , other . retry_on_timeout or self . retry_on_timeout , ) to_tf_dict () -> Dict [ str , Optional [ str ] | Optional [ int ] | Optional [ bool ] | Optional [ Dict [ str , Optional [ List [ str ]]]]] \u00b6 Source code in brickflow/engine/task.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def to_tf_dict ( self , ) -> Dict [ str , Optional [ str ] | Optional [ int ] | Optional [ bool ] | Optional [ Dict [ str , Optional [ List [ str ]]]], ]: email_not = ( self . email_notifications . to_tf_dict () if self . email_notifications is not None else {} ) return { \"email_notifications\" : email_not , \"timeout_seconds\" : self . timeout_seconds , \"max_retries\" : self . max_retries , \"min_retry_interval_millis\" : self . min_retry_interval_millis , \"retry_on_timeout\" : self . retry_on_timeout , } brickflow.engine.task.TaskType \u00b6 Bases: Enum Attributes \u00b6 CUSTOM_PYTHON_TASK = 'custom_python_task' class-attribute \u00b6 NOTEBOOK = 'notebook_task' class-attribute \u00b6 SQL = 'sql_task' class-attribute \u00b6","title":"Task"},{"location":"api/task/#brickflow.engine.task-classes","text":"","title":"Classes"},{"location":"api/task/#brickflow.engine.task.Task","text":"","title":"Task"},{"location":"api/task/#brickflow.engine.task.Task-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.Task.cluster","text":"","title":"cluster"},{"location":"api/task/#brickflow.engine.task.Task.custom_execute_callback","text":"","title":"custom_execute_callback"},{"location":"api/task/#brickflow.engine.task.Task.depends_on","text":"","title":"depends_on"},{"location":"api/task/#brickflow.engine.task.Task.description","text":"","title":"description"},{"location":"api/task/#brickflow.engine.task.Task.libraries","text":"","title":"libraries"},{"location":"api/task/#brickflow.engine.task.Task.task_func","text":"","title":"task_func"},{"location":"api/task/#brickflow.engine.task.Task.task_id","text":"","title":"task_id"},{"location":"api/task/#brickflow.engine.task.Task.task_settings","text":"","title":"task_settings"},{"location":"api/task/#brickflow.engine.task.Task.task_type","text":"","title":"task_type"},{"location":"api/task/#brickflow.engine.task.Task.trigger_rule","text":"","title":"trigger_rule"},{"location":"api/task/#brickflow.engine.task.Task.workflow","text":"","title":"workflow"},{"location":"api/task/#brickflow.engine.task.Task-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.Task.brickflow_default_params","text":"Source code in brickflow/engine/task.py 308 309 310 311 312 313 314 315 @property def brickflow_default_params ( self ) -> Dict [ str , str ]: return { BrickflowInternalVariables . workflow_id . value : self . workflow . name , # 2 braces to escape 1 BrickflowInternalVariables . task_id . value : f \" {{{{ { BrickflowBuiltInTaskVariables . task_key . name } }}}} \" , BrickflowInternalVariables . only_run_tasks . value : \"\" , }","title":"brickflow_default_params()"},{"location":"api/task/#brickflow.engine.task.Task.builtin_notebook_params","text":"Source code in brickflow/engine/task.py 299 300 301 302 @property def builtin_notebook_params ( self ) -> Dict [ str , str ]: # 2 braces to escape for 1 return { i . value : f \" {{{{ { i . name } }}}} \" for i in BrickflowBuiltInTaskVariables }","title":"builtin_notebook_params()"},{"location":"api/task/#brickflow.engine.task.Task.custom_task_parameters","text":"Source code in brickflow/engine/task.py 355 356 357 358 359 360 @property def custom_task_parameters ( self ) -> Dict [ str , Union [ str , None , numbers . Number ]]: spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) if spec . kwonlydefaults is None : return {} return { k : str ( v ) for k , v in spec . kwonlydefaults . items ()}","title":"custom_task_parameters()"},{"location":"api/task/#brickflow.engine.task.Task.depends_on_names","text":"Source code in brickflow/engine/task.py 287 288 289 290 291 292 293 @property def depends_on_names ( self ) -> Iterator [ str ]: for i in self . depends_on : if callable ( i ) and hasattr ( i , \"__name__\" ): yield i . __name__ else : yield str ( i )","title":"depends_on_names()"},{"location":"api/task/#brickflow.engine.task.Task.execute","text":"Source code in brickflow/engine/task.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 @with_brickflow_logger def execute ( self ) -> Any : # Workflow is: # 1. Check to see if there selected tasks and if there are is this task in the list # 2. Check to see if the previous task is skipped and trigger rule. # 3. Check to see if this a custom python task and execute it # 4. Execute the task function ctx . _set_current_task ( self . name ) _select_task_skip , _select_task_skip_reason = self . _skip_because_not_selected () if _select_task_skip is True : # check if this task is skipped due to task selection logging . info ( \"Skipping task... %s for reason: %s \" , self . name , _select_task_skip_reason , ) ctx . _reset_current_task () return _skip , reason = self . should_skip () if _skip is True : logging . info ( \"Skipping task... %s for reason: %s \" , self . name , reason ) ctx . task_coms . put ( self . name , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK ) ctx . _reset_current_task () return return_value = TaskComsObjectResult . NO_RESULTS if ( self . task_type == TaskType . CUSTOM_PYTHON_TASK and self . custom_execute_callback is not None ): resp : CustomTaskResponse = self . custom_execute_callback ( self ) if resp . push_return_value is True : return_value = resp . response else : # TODO: Inject context object return_value = self . task_func () ctx . task_coms . put ( self . name , RETURN_VALUE_KEY , return_value ) ctx . _reset_current_task () return return_value","title":"execute()"},{"location":"api/task/#brickflow.engine.task.Task.get_tf_obj","text":"Source code in brickflow/engine/task.py 317 318 319 320 321 322 323 324 325 326 327 328 def get_tf_obj ( self , entrypoint ) -> \"JobTaskNotebookTask\" : # type: ignore # noqa from brickflow.tf.databricks import JobTaskNotebookTask if self . task_type in [ TaskType . NOTEBOOK , TaskType . CUSTOM_PYTHON_TASK ]: return JobTaskNotebookTask ( notebook_path = entrypoint , base_parameters = { ** self . builtin_notebook_params , ** self . brickflow_default_params , ** ( self . custom_task_parameters or {}), # type: ignore }, )","title":"get_tf_obj()"},{"location":"api/task/#brickflow.engine.task.Task.is_valid_task_signature","text":"Source code in brickflow/engine/task.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def is_valid_task_signature ( self ) -> None : # only supports kwonlyargs with defaults spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) sig : inspect . Signature = inspect . signature ( self . task_func ) signature_error_msg = ( \"Task signatures only supports kwargs with defaults. or catch all varkw **kwargs\" \"For example def execute(*, variable_a=None, variable_b=None, **kwargs). \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) kwargs_default_error_msg = ( f \"Keyword arguments must be either None, String or number. \" f \"Please handle booleans via strings. \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) valid_case = spec . args == [] and spec . varargs is None and spec . defaults is None for _ , v in ( spec . kwonlydefaults or {}) . items (): if not ( isinstance ( v , ( numbers . Number , str )) or v is None ): raise InvalidTaskSignatureDefinition ( kwargs_default_error_msg ) if valid_case : return raise InvalidTaskSignatureDefinition ( signature_error_msg )","title":"is_valid_task_signature()"},{"location":"api/task/#brickflow.engine.task.Task.name","text":"Source code in brickflow/engine/task.py 304 305 306 @property def name ( self ) -> str : return self . task_id","title":"name()"},{"location":"api/task/#brickflow.engine.task.Task.parents","text":"Source code in brickflow/engine/task.py 283 284 285 @property def parents ( self ) -> List [ str ]: return list ( self . workflow . parents ( self . task_id ))","title":"parents()"},{"location":"api/task/#brickflow.engine.task.Task.should_skip","text":"Source code in brickflow/engine/task.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def should_skip ( self ) -> Tuple [ bool , Optional [ str ]]: # return true or false and reason node_skip_checks = [] for parent in self . parents : if parent != ROOT_NODE : try : task_to_not_skip = ctx . task_coms . get ( parent , BRANCH_SKIP_EXCEPT ) if self . name != task_to_not_skip : # set this task to skip hack to keep to empty to trigger failure # key look up will fail node_skip_checks . append ( True ) else : node_skip_checks . append ( False ) except Exception : # ignore errors as it probably doesnt exist # TODO: log errors node_skip_checks . append ( False ) if not node_skip_checks : return False , None if self . trigger_rule == BrickflowTriggerRule . NONE_FAILED : # by default a task failure automatically skips return self . _get_skip_with_reason ( all ( node_skip_checks ), \"At least one task before this were not successful\" , ) # default is BrickflowTriggerRule.ALL_SUCCESS return self . _get_skip_with_reason ( any ( node_skip_checks ), \"All tasks before this were not successful\" )","title":"should_skip()"},{"location":"api/task/#brickflow.engine.task.Task.task_func_name","text":"Source code in brickflow/engine/task.py 279 280 281 @property def task_func_name ( self ) -> str : return self . task_func . __name__","title":"task_func_name()"},{"location":"api/task/#brickflow.engine.task.Task.task_type_str","text":"Source code in brickflow/engine/task.py 295 296 297 @property def task_type_str ( self ) -> str : return self . task_type . value","title":"task_type_str()"},{"location":"api/task/#brickflow.engine.task.EmailNotifications","text":"","title":"EmailNotifications"},{"location":"api/task/#brickflow.engine.task.EmailNotifications-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.on_failure","text":"","title":"on_failure"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.on_start","text":"","title":"on_start"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.on_success","text":"","title":"on_success"},{"location":"api/task/#brickflow.engine.task.EmailNotifications-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.to_tf_dict","text":"Source code in brickflow/engine/task.py 205 206 207 208 209 210 def to_tf_dict ( self ) -> Dict [ str , Optional [ List [ str ]]]: return { \"on_start\" : self . on_start , \"on_failure\" : self . on_failure , \"on_success\" : self . on_success , }","title":"to_tf_dict()"},{"location":"api/task/#brickflow.engine.task.JarTaskLibrary","text":"Bases: StorageBasedTaskLibrary Parameters: Name Type Description Default jar str String to s3/dbfs path for jar required","title":"JarTaskLibrary"},{"location":"api/task/#brickflow.engine.task.JarTaskLibrary-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.JarTaskLibrary.jar","text":"","title":"jar"},{"location":"api/task/#brickflow.engine.task.EggTaskLibrary","text":"Bases: StorageBasedTaskLibrary Parameters: Name Type Description Default egg str String to s3/dbfs path for egg required","title":"EggTaskLibrary"},{"location":"api/task/#brickflow.engine.task.EggTaskLibrary-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.EggTaskLibrary.egg","text":"","title":"egg"},{"location":"api/task/#brickflow.engine.task.WheelTaskLibrary","text":"Bases: StorageBasedTaskLibrary Parameters: Name Type Description Default whl str String to s3/dbfs path for whl required","title":"WheelTaskLibrary"},{"location":"api/task/#brickflow.engine.task.WheelTaskLibrary-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.WheelTaskLibrary.whl","text":"","title":"whl"},{"location":"api/task/#brickflow.engine.task.PypiTaskLibrary","text":"Bases: TaskLibrary Parameters: Name Type Description Default package str The package in pypi i.e. requests, requests==x.y.z, git+ https://github.com/stikkireddy/brickflow.git required repo Optional [ str ] The repository where the package can be found. By default pypi is used None","title":"PypiTaskLibrary"},{"location":"api/task/#brickflow.engine.task.PypiTaskLibrary-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.PypiTaskLibrary.package","text":"","title":"package"},{"location":"api/task/#brickflow.engine.task.PypiTaskLibrary.repo","text":"","title":"repo"},{"location":"api/task/#brickflow.engine.task.PypiTaskLibrary-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.PypiTaskLibrary.dict","text":"Source code in brickflow/engine/task.py 157 158 159 @property def dict ( self ) -> Dict [ str , Union [ str , Dict [ str , str ]]]: return { \"pypi\" : dataclasses . asdict ( self )}","title":"dict()"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary","text":"Bases: TaskLibrary Parameters: Name Type Description Default coordinates str Gradle-style Maven coordinates. For example: org.jsoup:jsoup:1.7.2. required repo Optional [ str ] Maven repo to install the Maven package from. If omitted, both Maven Central Repository and Spark Packages are searched. None exclusions Optional [ List [ str ]] List of dependences to exclude. For example: [\"slf4j:slf4j\", \"*:hadoop-client\"]. Maven dependency exclusions: https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html . None","title":"MavenTaskLibrary"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary.coordinates","text":"","title":"coordinates"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary.exclusions","text":"","title":"exclusions"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary.repo","text":"","title":"repo"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.MavenTaskLibrary.dict","text":"Source code in brickflow/engine/task.py 178 179 180 @property def dict ( self ) -> Dict [ str , Union [ str , Dict [ str , str ]]]: return { \"maven\" : dataclasses . asdict ( self )}","title":"dict()"},{"location":"api/task/#brickflow.engine.task.CranTaskLibrary","text":"Bases: TaskLibrary Parameters: Name Type Description Default package str The name of the CRAN package to install. required repo Optional [ str ] The repository where the package can be found. If not specified, the default CRAN repo is used. None","title":"CranTaskLibrary"},{"location":"api/task/#brickflow.engine.task.CranTaskLibrary-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.CranTaskLibrary.package","text":"","title":"package"},{"location":"api/task/#brickflow.engine.task.CranTaskLibrary.repo","text":"","title":"repo"},{"location":"api/task/#brickflow.engine.task.CranTaskLibrary-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.CranTaskLibrary.dict","text":"Source code in brickflow/engine/task.py 194 195 196 @property def dict ( self ) -> Dict [ str , Union [ str , Dict [ str , str ]]]: return { \"cran\" : dataclasses . asdict ( self )}","title":"dict()"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule","text":"Bases: Enum","title":"BrickflowTriggerRule"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule.ALL_SUCCESS","text":"","title":"ALL_SUCCESS"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule.NONE_FAILED","text":"","title":"NONE_FAILED"},{"location":"api/task/#brickflow.engine.task.BrickflowTaskEnvVars","text":"Bases: Enum","title":"BrickflowTaskEnvVars"},{"location":"api/task/#brickflow.engine.task.BrickflowTaskEnvVars-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.BrickflowTaskEnvVars.BRICKFLOW_SELECT_TASKS","text":"","title":"BRICKFLOW_SELECT_TASKS"},{"location":"api/task/#brickflow.engine.task.TaskSettings","text":"","title":"TaskSettings"},{"location":"api/task/#brickflow.engine.task.TaskSettings-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.TaskSettings.email_notifications","text":"","title":"email_notifications"},{"location":"api/task/#brickflow.engine.task.TaskSettings.max_retries","text":"","title":"max_retries"},{"location":"api/task/#brickflow.engine.task.TaskSettings.min_retry_interval_millis","text":"","title":"min_retry_interval_millis"},{"location":"api/task/#brickflow.engine.task.TaskSettings.retry_on_timeout","text":"","title":"retry_on_timeout"},{"location":"api/task/#brickflow.engine.task.TaskSettings.timeout_seconds","text":"","title":"timeout_seconds"},{"location":"api/task/#brickflow.engine.task.TaskSettings-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.TaskSettings.merge","text":"Source code in brickflow/engine/task.py 221 222 223 224 225 226 227 228 229 230 231 def merge ( self , other : Optional [ \"TaskSettings\" ]) -> \"TaskSettings\" : # overrides top level values if other is None : return self return TaskSettings ( other . email_notifications or self . email_notifications , other . timeout_seconds or self . timeout_seconds or 0 , other . max_retries or self . max_retries , other . min_retry_interval_millis or self . min_retry_interval_millis , other . retry_on_timeout or self . retry_on_timeout , )","title":"merge()"},{"location":"api/task/#brickflow.engine.task.TaskSettings.to_tf_dict","text":"Source code in brickflow/engine/task.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def to_tf_dict ( self , ) -> Dict [ str , Optional [ str ] | Optional [ int ] | Optional [ bool ] | Optional [ Dict [ str , Optional [ List [ str ]]]], ]: email_not = ( self . email_notifications . to_tf_dict () if self . email_notifications is not None else {} ) return { \"email_notifications\" : email_not , \"timeout_seconds\" : self . timeout_seconds , \"max_retries\" : self . max_retries , \"min_retry_interval_millis\" : self . min_retry_interval_millis , \"retry_on_timeout\" : self . retry_on_timeout , }","title":"to_tf_dict()"},{"location":"api/task/#brickflow.engine.task.TaskType","text":"Bases: Enum","title":"TaskType"},{"location":"api/task/#brickflow.engine.task.TaskType-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.TaskType.CUSTOM_PYTHON_TASK","text":"","title":"CUSTOM_PYTHON_TASK"},{"location":"api/task/#brickflow.engine.task.TaskType.NOTEBOOK","text":"","title":"NOTEBOOK"},{"location":"api/task/#brickflow.engine.task.TaskType.SQL","text":"","title":"SQL"},{"location":"api/workflow/","text":"Classes \u00b6 brickflow.engine.workflow.Workflow dataclass \u00b6 Attributes \u00b6 active_task : Optional [ str ] = None class-attribute \u00b6 clusters : List [ Cluster ] = field ( default_factory = lambda : []) class-attribute \u00b6 default_cluster : Optional [ Cluster ] = None class-attribute \u00b6 default_task_settings : TaskSettings = TaskSettings () class-attribute \u00b6 graph : nx . DiGraph = nx . DiGraph () class-attribute \u00b6 libraries : List [ TaskLibrary ] = field ( default_factory = lambda : []) class-attribute \u00b6 max_concurrent_runs : int = 1 class-attribute \u00b6 permissions : WorkflowPermissions = WorkflowPermissions () class-attribute \u00b6 tags : Optional [ Dict [ str , str ]] = None class-attribute \u00b6 tasks : Dict [ str , Task ] = field ( default_factory = lambda : {}) class-attribute \u00b6 Functions \u00b6 bfs_layers () -> List [ str ] property \u00b6 Source code in brickflow/engine/workflow.py 148 149 150 @property def bfs_layers ( self ) -> List [ str ]: return list ( nx . bfs_layers ( self . graph , ROOT_NODE ))[ 1 :] bfs_task_iter () -> Iterator [ Task ] \u00b6 Source code in brickflow/engine/workflow.py 156 157 158 159 def bfs_task_iter ( self ) -> Iterator [ Task ]: for layer in self . bfs_layers : for task_key in layer : yield self . get_task ( task_key ) check_no_active_task () -> None \u00b6 Source code in brickflow/engine/workflow.py 164 165 166 167 168 169 def check_no_active_task ( self ) -> None : if self . active_task is not None : raise AnotherActiveTaskError ( \"You are calling another active task in another task. \" \"Please abstract the code more.\" ) get_task ( task_id : str ) -> Task \u00b6 Source code in brickflow/engine/workflow.py 171 172 173 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def get_task ( self , task_id : str ) -> Task : return self . tasks [ task_id ] name () -> str property \u00b6 Source code in brickflow/engine/workflow.py 108 109 110 @property def name ( self ) -> str : return self . _name parents ( node : str ) -> Iterator \u00b6 Source code in brickflow/engine/workflow.py 161 162 def parents ( self , node : str ) -> Iterator : return self . graph . predecessors ( node ) pop_task ( task_id : str ) -> None \u00b6 Source code in brickflow/engine/workflow.py 175 176 177 178 179 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def pop_task ( self , task_id : str ) -> None : # Pop from dict and graph self . tasks . pop ( task_id ) self . graph . remove_node ( task_id ) task ( task_func : Callable = None , name : str = None , cluster : Optional [ Cluster ] = None , libraries : Optional [ List [ TaskLibrary ]] = None , task_type : TaskType = TaskType . NOTEBOOK , depends_on : Optional [ Union [ Callable , str , List [ Union [ Callable , str ]]]] = None , trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS , custom_execute_callback : Callable = None ) -> Callable \u00b6 Source code in brickflow/engine/workflow.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def task ( self , task_func : Callable = None , name : str = None , cluster : Optional [ Cluster ] = None , libraries : Optional [ List [ TaskLibrary ]] = None , task_type : TaskType = TaskType . NOTEBOOK , depends_on : Optional [ Union [ Callable , str , List [ Union [ Callable , str ]]]] = None , trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS , custom_execute_callback : Callable = None , ) -> Callable : def task_wrapper ( f : Callable ) -> Callable : task_id = name or f . __name__ self . _add_task ( f , task_id , cluster = cluster , task_type = task_type , libraries = libraries , depends_on = depends_on , trigger_rule = trigger_rule , custom_execute_callback = custom_execute_callback , ) @functools . wraps ( f ) def func ( * args , ** kwargs ): # type: ignore try : self . check_no_active_task () self . _set_active_task ( task_id ) resp = f ( * args , ** kwargs ) return resp except Exception as e : self . _reset_active_task () raise e finally : self . _reset_active_task () return func if task_func is not None : if callable ( task_func ): return task_wrapper ( task_func ) else : raise NoCallableTaskError ( \"Please use task decorator against a callable function.\" ) return task_wrapper task_exists ( task_id : str ) -> bool \u00b6 Source code in brickflow/engine/workflow.py 181 182 def task_exists ( self , task_id : str ) -> bool : return task_id in self . tasks task_iter () -> Iterator [ Task ] \u00b6 Source code in brickflow/engine/workflow.py 152 153 154 def task_iter ( self ) -> Iterator [ Task ]: for task in self . bfs_task_iter (): yield task unique_new_clusters () -> List [ Cluster ] property \u00b6 Source code in brickflow/engine/workflow.py 112 113 114 115 116 117 118 119 120 121 @property def unique_new_clusters ( self ) -> List [ Cluster ]: clusters = ( [ v . cluster for k , v in self . tasks . items ()] + self . clusters + [ self . default_cluster ] ) return list ( set ([ c for c in clusters if c is not None and c . is_new_job_cluster ]) ) unique_new_clusters_dict () -> List [ Dict [ str , Any ]] \u00b6 Source code in brickflow/engine/workflow.py 123 124 125 126 127 128 129 def unique_new_clusters_dict ( self ) -> List [ Dict [ str , Any ]]: self . validate_new_clusters_with_unique_names () all_unique_clusters = self . unique_new_clusters return [ { \"job_cluster_key\" : c . name , \"new_cluster\" : c . dict } for c in all_unique_clusters ] validate_new_clusters_with_unique_names () -> None \u00b6 Source code in brickflow/engine/workflow.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def validate_new_clusters_with_unique_names ( self ) -> None : all_unique_clusters = self . unique_new_clusters unique_name_list : Dict [ str , Optional [ str ]] = {} duplicates = [] for cluster in all_unique_clusters : if cluster . name not in unique_name_list : unique_name_list [ cluster . name ] = None else : duplicates . append ( cluster . name ) duplicate_list = list ( set ( duplicates )) if len ( duplicate_list ) > 0 : raise DuplicateClustersDefinitionError ( f \"Found duplicate cluster definitions in your workflow: { self . name } , \" f \"with names: { duplicate_list } \" ) brickflow.engine.workflow.User \u00b6 Bases: ScimEntity Functions \u00b6 to_access_control () -> Dict [ str , str ] \u00b6 Source code in brickflow/engine/workflow.py 38 39 def to_access_control ( self ) -> Dict [ str , str ]: return { \"user_name\" : self . name } brickflow.engine.workflow.Group \u00b6 Bases: ScimEntity Functions \u00b6 to_access_control () -> Dict [ str , str ] \u00b6 Source code in brickflow/engine/workflow.py 43 44 def to_access_control ( self ) -> Dict [ str , str ]: return { \"group_name\" : self . name } brickflow.engine.workflow.ServicePrincipal \u00b6 Bases: ScimEntity Functions \u00b6 to_access_control () -> Dict [ str , str ] \u00b6 Source code in brickflow/engine/workflow.py 48 49 def to_access_control ( self ) -> Dict [ str , str ]: return { \"service_principal_name\" : self . name }","title":"Workflow"},{"location":"api/workflow/#brickflow.engine.workflow-classes","text":"","title":"Classes"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow","text":"","title":"Workflow"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow-attributes","text":"","title":"Attributes"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.active_task","text":"","title":"active_task"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.clusters","text":"","title":"clusters"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.default_cluster","text":"","title":"default_cluster"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.default_task_settings","text":"","title":"default_task_settings"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.graph","text":"","title":"graph"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.libraries","text":"","title":"libraries"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.max_concurrent_runs","text":"","title":"max_concurrent_runs"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.permissions","text":"","title":"permissions"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.tags","text":"","title":"tags"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.tasks","text":"","title":"tasks"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.bfs_layers","text":"Source code in brickflow/engine/workflow.py 148 149 150 @property def bfs_layers ( self ) -> List [ str ]: return list ( nx . bfs_layers ( self . graph , ROOT_NODE ))[ 1 :]","title":"bfs_layers()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.bfs_task_iter","text":"Source code in brickflow/engine/workflow.py 156 157 158 159 def bfs_task_iter ( self ) -> Iterator [ Task ]: for layer in self . bfs_layers : for task_key in layer : yield self . get_task ( task_key )","title":"bfs_task_iter()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.check_no_active_task","text":"Source code in brickflow/engine/workflow.py 164 165 166 167 168 169 def check_no_active_task ( self ) -> None : if self . active_task is not None : raise AnotherActiveTaskError ( \"You are calling another active task in another task. \" \"Please abstract the code more.\" )","title":"check_no_active_task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.get_task","text":"Source code in brickflow/engine/workflow.py 171 172 173 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def get_task ( self , task_id : str ) -> Task : return self . tasks [ task_id ]","title":"get_task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.name","text":"Source code in brickflow/engine/workflow.py 108 109 110 @property def name ( self ) -> str : return self . _name","title":"name()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.parents","text":"Source code in brickflow/engine/workflow.py 161 162 def parents ( self , node : str ) -> Iterator : return self . graph . predecessors ( node )","title":"parents()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.pop_task","text":"Source code in brickflow/engine/workflow.py 175 176 177 178 179 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def pop_task ( self , task_id : str ) -> None : # Pop from dict and graph self . tasks . pop ( task_id ) self . graph . remove_node ( task_id )","title":"pop_task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.task","text":"Source code in brickflow/engine/workflow.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def task ( self , task_func : Callable = None , name : str = None , cluster : Optional [ Cluster ] = None , libraries : Optional [ List [ TaskLibrary ]] = None , task_type : TaskType = TaskType . NOTEBOOK , depends_on : Optional [ Union [ Callable , str , List [ Union [ Callable , str ]]]] = None , trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS , custom_execute_callback : Callable = None , ) -> Callable : def task_wrapper ( f : Callable ) -> Callable : task_id = name or f . __name__ self . _add_task ( f , task_id , cluster = cluster , task_type = task_type , libraries = libraries , depends_on = depends_on , trigger_rule = trigger_rule , custom_execute_callback = custom_execute_callback , ) @functools . wraps ( f ) def func ( * args , ** kwargs ): # type: ignore try : self . check_no_active_task () self . _set_active_task ( task_id ) resp = f ( * args , ** kwargs ) return resp except Exception as e : self . _reset_active_task () raise e finally : self . _reset_active_task () return func if task_func is not None : if callable ( task_func ): return task_wrapper ( task_func ) else : raise NoCallableTaskError ( \"Please use task decorator against a callable function.\" ) return task_wrapper","title":"task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.task_exists","text":"Source code in brickflow/engine/workflow.py 181 182 def task_exists ( self , task_id : str ) -> bool : return task_id in self . tasks","title":"task_exists()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.task_iter","text":"Source code in brickflow/engine/workflow.py 152 153 154 def task_iter ( self ) -> Iterator [ Task ]: for task in self . bfs_task_iter (): yield task","title":"task_iter()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.unique_new_clusters","text":"Source code in brickflow/engine/workflow.py 112 113 114 115 116 117 118 119 120 121 @property def unique_new_clusters ( self ) -> List [ Cluster ]: clusters = ( [ v . cluster for k , v in self . tasks . items ()] + self . clusters + [ self . default_cluster ] ) return list ( set ([ c for c in clusters if c is not None and c . is_new_job_cluster ]) )","title":"unique_new_clusters()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.unique_new_clusters_dict","text":"Source code in brickflow/engine/workflow.py 123 124 125 126 127 128 129 def unique_new_clusters_dict ( self ) -> List [ Dict [ str , Any ]]: self . validate_new_clusters_with_unique_names () all_unique_clusters = self . unique_new_clusters return [ { \"job_cluster_key\" : c . name , \"new_cluster\" : c . dict } for c in all_unique_clusters ]","title":"unique_new_clusters_dict()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.validate_new_clusters_with_unique_names","text":"Source code in brickflow/engine/workflow.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def validate_new_clusters_with_unique_names ( self ) -> None : all_unique_clusters = self . unique_new_clusters unique_name_list : Dict [ str , Optional [ str ]] = {} duplicates = [] for cluster in all_unique_clusters : if cluster . name not in unique_name_list : unique_name_list [ cluster . name ] = None else : duplicates . append ( cluster . name ) duplicate_list = list ( set ( duplicates )) if len ( duplicate_list ) > 0 : raise DuplicateClustersDefinitionError ( f \"Found duplicate cluster definitions in your workflow: { self . name } , \" f \"with names: { duplicate_list } \" )","title":"validate_new_clusters_with_unique_names()"},{"location":"api/workflow/#brickflow.engine.workflow.User","text":"Bases: ScimEntity","title":"User"},{"location":"api/workflow/#brickflow.engine.workflow.User-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.User.to_access_control","text":"Source code in brickflow/engine/workflow.py 38 39 def to_access_control ( self ) -> Dict [ str , str ]: return { \"user_name\" : self . name }","title":"to_access_control()"},{"location":"api/workflow/#brickflow.engine.workflow.Group","text":"Bases: ScimEntity","title":"Group"},{"location":"api/workflow/#brickflow.engine.workflow.Group-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.Group.to_access_control","text":"Source code in brickflow/engine/workflow.py 43 44 def to_access_control ( self ) -> Dict [ str , str ]: return { \"group_name\" : self . name }","title":"to_access_control()"},{"location":"api/workflow/#brickflow.engine.workflow.ServicePrincipal","text":"Bases: ScimEntity","title":"ServicePrincipal"},{"location":"api/workflow/#brickflow.engine.workflow.ServicePrincipal-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.ServicePrincipal.to_access_control","text":"Source code in brickflow/engine/workflow.py 48 49 def to_access_control ( self ) -> Dict [ str , str ]: return { \"service_principal_name\" : self . name }","title":"to_access_control()"},{"location":"cli/reference/","text":"This page provides documentation for our command line tools. brickflow \u00b6 CLI for managing Databricks Workflows Usage: brickflow [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. cdktf \u00b6 CLI for deploying workflow projects. Usage: brickflow cdktf [OPTIONS] Options: --help Show this message and exit. deploy \u00b6 CLI for deploying workflow projects. Usage: brickflow deploy [OPTIONS] Options: --help Show this message and exit. diff \u00b6 CLI for deploying workflow projects. Usage: brickflow diff [OPTIONS] Options: --help Show this message and exit. docs \u00b6 Use to open docs in your browser... Usage: brickflow docs [OPTIONS] Options: --help Show this message and exit. init \u00b6 Initialize your project with Brickflows... Usage: brickflow init [OPTIONS] Options: -n, --project-name TEXT -p, --git-provider [github|gitlab] -w, --workflows-dir DIRECTORY --help Show this message and exit. bf \u00b6 CLI for managing Databricks Workflows Usage: bf [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit. cdktf \u00b6 CLI for deploying workflow projects. Usage: bf cdktf [OPTIONS] Options: --help Show this message and exit. deploy \u00b6 CLI for deploying workflow projects. Usage: bf deploy [OPTIONS] Options: --help Show this message and exit. diff \u00b6 CLI for deploying workflow projects. Usage: bf diff [OPTIONS] Options: --help Show this message and exit. docs \u00b6 Use to open docs in your browser... Usage: bf docs [OPTIONS] Options: --help Show this message and exit. init \u00b6 Initialize your project with Brickflows... Usage: bf init [OPTIONS] Options: -n, --project-name TEXT -p, --git-provider [github|gitlab] -w, --workflows-dir DIRECTORY --help Show this message and exit.","title":"Commands"},{"location":"cli/reference/#brickflow","text":"CLI for managing Databricks Workflows Usage: brickflow [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit.","title":"brickflow"},{"location":"cli/reference/#cdktf","text":"CLI for deploying workflow projects. Usage: brickflow cdktf [OPTIONS] Options: --help Show this message and exit.","title":"cdktf"},{"location":"cli/reference/#deploy","text":"CLI for deploying workflow projects. Usage: brickflow deploy [OPTIONS] Options: --help Show this message and exit.","title":"deploy"},{"location":"cli/reference/#diff","text":"CLI for deploying workflow projects. Usage: brickflow diff [OPTIONS] Options: --help Show this message and exit.","title":"diff"},{"location":"cli/reference/#docs","text":"Use to open docs in your browser... Usage: brickflow docs [OPTIONS] Options: --help Show this message and exit.","title":"docs"},{"location":"cli/reference/#init","text":"Initialize your project with Brickflows... Usage: brickflow init [OPTIONS] Options: -n, --project-name TEXT -p, --git-provider [github|gitlab] -w, --workflows-dir DIRECTORY --help Show this message and exit.","title":"init"},{"location":"cli/reference/#bf","text":"CLI for managing Databricks Workflows Usage: bf [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --help Show this message and exit.","title":"bf"},{"location":"cli/reference/#cdktf_1","text":"CLI for deploying workflow projects. Usage: bf cdktf [OPTIONS] Options: --help Show this message and exit.","title":"cdktf"},{"location":"cli/reference/#deploy_1","text":"CLI for deploying workflow projects. Usage: bf deploy [OPTIONS] Options: --help Show this message and exit.","title":"deploy"},{"location":"cli/reference/#diff_1","text":"CLI for deploying workflow projects. Usage: bf diff [OPTIONS] Options: --help Show this message and exit.","title":"diff"},{"location":"cli/reference/#docs_1","text":"Use to open docs in your browser... Usage: bf docs [OPTIONS] Options: --help Show this message and exit.","title":"docs"},{"location":"cli/reference/#init_1","text":"Initialize your project with Brickflows... Usage: bf init [OPTIONS] Options: -n, --project-name TEXT -p, --git-provider [github|gitlab] -w, --workflows-dir DIRECTORY --help Show this message and exit.","title":"init"},{"location":"examples/basic-00/","text":"","title":"Production Readiness Checklist"},{"location":"examples/basic-01/","text":"","title":"Basic Dag With Dependancies"},{"location":"examples/basic-02/","text":"","title":"Branching and then Join"},{"location":"examples/basic-03/","text":"","title":"Short Circuiting your DAG"},{"location":"examples/basic-04/","text":"","title":"Dynamically creating tasks"},{"location":"faq/faq/","text":"","title":"FAQ"},{"location":"getting-started/airflow-concepts/","text":"","title":"Airflow Concepts"},{"location":"getting-started/databricks-workflow-concepts/","text":"","title":"Databricks Workflows"},{"location":"getting-started/environment-variables/","text":"","title":"Environment Variables"},{"location":"getting-started/installation/","text":"","title":"Installation"},{"location":"getting-started/projects/","text":"","title":"Projects"},{"location":"getting-started/tasks/","text":"","title":"Tasks"},{"location":"getting-started/workflows/","text":"","title":"Workflows"},{"location":"guides/airflow-operators/","text":"","title":"Using Airflow Operators"},{"location":"guides/dag-to-workflows/","text":"","title":"Airflow DAGs to Workflows"},{"location":"guides/dev-loop/","text":"","title":"Development Loop"},{"location":"guides/dlt-pipelines/","text":"","title":"Creating DLT Pipelines"},{"location":"guides/setup/","text":"","title":"Setting up brickflow"},{"location":"guides/sql-warehouses/","text":"","title":"Working with SQL Warehouses"},{"location":"guides/submitting-sql-files/","text":"","title":"Submitting SQL Files"}]}