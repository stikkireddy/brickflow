{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BrickFlow \u00b6 BrickFlow is a CLI tool for development and deployment of Python based Databricks Workflows in a declarative way. Concept \u00b6 brickflow aims to improve development experience for building any pipelines on databricks via: Providing a declarative way to describe workflows via decorators Provide intelligent defaults to compute targets Provide a code and git first approach to managing and deploying workflows Use IAC such as terraform to manage the state and deploy jobs and their infrastructure. CLI tool helps facilitate setting up a projects Provides additional functionality through the context library to be able to do additional things for workflows. Limitations & Missing Features in the Project \u00b6 Docs (WIP) Notebook Tasks Serverless Sql Tasks DLT Pipeline Tasks Support for Job Clusters Support for Look Up Clusters Support for Warehouses Support for using existing warehouses CLI for initializing repo to setup entry points and required files CLI for visualizing workflow locally using a graphing tool Legal Information \u00b6 Support notice This software is provided as-is and is not officially supported by Sriharsha Tikkireddy nor Databricks through customer technical support channels. Support, questions, and feature requests can be communicated through the Issues page of the repo . Please understand that issues with the use of this code will not be answered or investigated by Databricks Support. Feedback \u00b6 Issues with brickflow ? Found a bug? Have a great idea for an addition? Want to improve the documentation? Please feel free to file an issue . Contributing \u00b6 To contribute please fork and create a pull request.","title":"Home"},{"location":"#brickflow","text":"BrickFlow is a CLI tool for development and deployment of Python based Databricks Workflows in a declarative way.","title":"BrickFlow"},{"location":"#concept","text":"brickflow aims to improve development experience for building any pipelines on databricks via: Providing a declarative way to describe workflows via decorators Provide intelligent defaults to compute targets Provide a code and git first approach to managing and deploying workflows Use IAC such as terraform to manage the state and deploy jobs and their infrastructure. CLI tool helps facilitate setting up a projects Provides additional functionality through the context library to be able to do additional things for workflows.","title":"Concept"},{"location":"#limitations-missing-features-in-the-project","text":"Docs (WIP) Notebook Tasks Serverless Sql Tasks DLT Pipeline Tasks Support for Job Clusters Support for Look Up Clusters Support for Warehouses Support for using existing warehouses CLI for initializing repo to setup entry points and required files CLI for visualizing workflow locally using a graphing tool","title":"Limitations &amp; Missing Features in the Project"},{"location":"#legal-information","text":"Support notice This software is provided as-is and is not officially supported by Sriharsha Tikkireddy nor Databricks through customer technical support channels. Support, questions, and feature requests can be communicated through the Issues page of the repo . Please understand that issues with the use of this code will not be answered or investigated by Databricks Support.","title":"Legal Information"},{"location":"#feedback","text":"Issues with brickflow ? Found a bug? Have a great idea for an addition? Want to improve the documentation? Please feel free to file an issue .","title":"Feedback"},{"location":"#contributing","text":"To contribute please fork and create a pull request.","title":"Contributing"},{"location":"api/cli/","text":"Classes \u00b6 brickflow.cli.CdktfCmd \u00b6 Bases: click . Group Functions \u00b6 get_command ( ctx : click . Context , cmd_name : str ) -> Optional [ click . Command ] \u00b6 Source code in brickflow/cli/__init__.py 29 30 31 32 33 34 35 36 def get_command ( self , ctx : click . Context , cmd_name : str ) -> Optional [ click . Command ]: if cmd_name == \"cdktf\" : return cdktf_command () else : rv = click . Group . get_command ( self , ctx , cmd_name ) if rv is not None : return rv ctx . fail ( f \"No such command ' { cmd_name } '.\" ) Functions \u00b6 brickflow . cli . cdktf () -> None \u00b6 CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 57 58 59 60 61 62 @cli . command def cdktf () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover brickflow . cli . cdktf_command () -> click . Command \u00b6 Source code in brickflow/cli/__init__.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def cdktf_command () -> click . Command : @click . command ( name = \"cdktf_cmd\" , short_help = \"CLI for deploying workflow projects.\" , context_settings = { \"ignore_unknown_options\" : True }, add_help_option = False , ) @click . argument ( \"args\" , nargs =- 1 ) def cmd ( args : List [ str ]) -> None : my_env = os . environ . copy () try : subprocess . run ([ \"cdktf\" , * args ], check = True , env = my_env ) except subprocess . CalledProcessError as e : raise ClickException ( str ( e )) return cmd brickflow . cli . cli () -> None \u00b6 CLI for managing Databricks Workflows Source code in brickflow/cli/__init__.py 39 40 41 @click . group ( cls = CdktfCmd ) def cli () -> None : \"\"\"CLI for managing Databricks Workflows\"\"\" brickflow . cli . docs () -> None \u00b6 Use to open docs in your browser... Source code in brickflow/cli/__init__.py 50 51 52 53 54 @cli . command def docs () -> None : \"\"\"Use to open docs in your browser...\"\"\" webbrowser . open ( \"https://github.com/stikkireddy/brickflow\" , new = 2 ) click . echo ( \"Opening browser for docs...\" ) brickflow . cli . init () -> None \u00b6 Initialize your project with Brickflows... Source code in brickflow/cli/__init__.py 44 45 46 47 @cli . command def init () -> None : \"\"\"Initialize your project with Brickflows...\"\"\" click . echo ( \"hello world\" )","title":"CLI"},{"location":"api/cli/#brickflow.cli-classes","text":"","title":"Classes"},{"location":"api/cli/#brickflow.cli.CdktfCmd","text":"Bases: click . Group","title":"CdktfCmd"},{"location":"api/cli/#brickflow.cli.CdktfCmd-functions","text":"","title":"Functions"},{"location":"api/cli/#brickflow.cli.CdktfCmd.get_command","text":"Source code in brickflow/cli/__init__.py 29 30 31 32 33 34 35 36 def get_command ( self , ctx : click . Context , cmd_name : str ) -> Optional [ click . Command ]: if cmd_name == \"cdktf\" : return cdktf_command () else : rv = click . Group . get_command ( self , ctx , cmd_name ) if rv is not None : return rv ctx . fail ( f \"No such command ' { cmd_name } '.\" )","title":"get_command()"},{"location":"api/cli/#brickflow.cli-functions","text":"","title":"Functions"},{"location":"api/cli/#brickflow.cli.cdktf","text":"CLI for deploying workflow projects. Source code in brickflow/cli/__init__.py 57 58 59 60 61 62 @cli . command def cdktf () -> None : \"\"\"CLI for deploying workflow projects.\"\"\" # Hack for having cdktf show up as a command in brickflow # with documentation. pass # pragma: no cover","title":"cdktf()"},{"location":"api/cli/#brickflow.cli.cdktf_command","text":"Source code in brickflow/cli/__init__.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def cdktf_command () -> click . Command : @click . command ( name = \"cdktf_cmd\" , short_help = \"CLI for deploying workflow projects.\" , context_settings = { \"ignore_unknown_options\" : True }, add_help_option = False , ) @click . argument ( \"args\" , nargs =- 1 ) def cmd ( args : List [ str ]) -> None : my_env = os . environ . copy () try : subprocess . run ([ \"cdktf\" , * args ], check = True , env = my_env ) except subprocess . CalledProcessError as e : raise ClickException ( str ( e )) return cmd","title":"cdktf_command()"},{"location":"api/cli/#brickflow.cli.cli","text":"CLI for managing Databricks Workflows Source code in brickflow/cli/__init__.py 39 40 41 @click . group ( cls = CdktfCmd ) def cli () -> None : \"\"\"CLI for managing Databricks Workflows\"\"\"","title":"cli()"},{"location":"api/cli/#brickflow.cli.docs","text":"Use to open docs in your browser... Source code in brickflow/cli/__init__.py 50 51 52 53 54 @cli . command def docs () -> None : \"\"\"Use to open docs in your browser...\"\"\" webbrowser . open ( \"https://github.com/stikkireddy/brickflow\" , new = 2 ) click . echo ( \"Opening browser for docs...\" )","title":"docs()"},{"location":"api/cli/#brickflow.cli.init","text":"Initialize your project with Brickflows... Source code in brickflow/cli/__init__.py 44 45 46 47 @cli . command def init () -> None : \"\"\"Initialize your project with Brickflows...\"\"\" click . echo ( \"hello world\" )","title":"init()"},{"location":"api/compute/","text":"Classes \u00b6 brickflow.engine.compute.Compute dataclass \u00b6 Attributes \u00b6 beta : bool = False class-attribute \u00b6 category : str = 'Memory Optimized' class-attribute \u00b6 cluster_max_vcpus : int = 64 class-attribute \u00b6 cluster_min_vcpus : int = 64 class-attribute \u00b6 compute_id : str class-attribute \u00b6 delta_cache : bool = True class-attribute \u00b6 gb_per_core : Optional [ int ] = None class-attribute \u00b6 genomics : bool = False class-attribute \u00b6 gpu : bool = False class-attribute \u00b6 graviton : bool = True class-attribute \u00b6 latest : bool = False class-attribute \u00b6 lts : bool = True class-attribute \u00b6 min_gpus_per_worker : int = 0 class-attribute \u00b6 min_memory_gb_per_worker : int = 32 class-attribute \u00b6 ml : bool = False class-attribute \u00b6 photon : bool = True class-attribute \u00b6 photon_driver : Optional [ bool ] = None class-attribute \u00b6 photon_worker : Optional [ bool ] = None class-attribute \u00b6 spark_version : Optional [ str ] = None class-attribute \u00b6 support_port_forwarding : bool = False class-attribute \u00b6 Functions \u00b6 set_to_default () -> None \u00b6 Source code in brickflow/engine/compute.py 82 83 def set_to_default ( self ) -> None : self . compute_id = \"default\"","title":"Compute"},{"location":"api/compute/#brickflow.engine.compute-classes","text":"","title":"Classes"},{"location":"api/compute/#brickflow.engine.compute.Compute","text":"","title":"Compute"},{"location":"api/compute/#brickflow.engine.compute.Compute-attributes","text":"","title":"Attributes"},{"location":"api/compute/#brickflow.engine.compute.Compute.beta","text":"","title":"beta"},{"location":"api/compute/#brickflow.engine.compute.Compute.category","text":"","title":"category"},{"location":"api/compute/#brickflow.engine.compute.Compute.cluster_max_vcpus","text":"","title":"cluster_max_vcpus"},{"location":"api/compute/#brickflow.engine.compute.Compute.cluster_min_vcpus","text":"","title":"cluster_min_vcpus"},{"location":"api/compute/#brickflow.engine.compute.Compute.compute_id","text":"","title":"compute_id"},{"location":"api/compute/#brickflow.engine.compute.Compute.delta_cache","text":"","title":"delta_cache"},{"location":"api/compute/#brickflow.engine.compute.Compute.gb_per_core","text":"","title":"gb_per_core"},{"location":"api/compute/#brickflow.engine.compute.Compute.genomics","text":"","title":"genomics"},{"location":"api/compute/#brickflow.engine.compute.Compute.gpu","text":"","title":"gpu"},{"location":"api/compute/#brickflow.engine.compute.Compute.graviton","text":"","title":"graviton"},{"location":"api/compute/#brickflow.engine.compute.Compute.latest","text":"","title":"latest"},{"location":"api/compute/#brickflow.engine.compute.Compute.lts","text":"","title":"lts"},{"location":"api/compute/#brickflow.engine.compute.Compute.min_gpus_per_worker","text":"","title":"min_gpus_per_worker"},{"location":"api/compute/#brickflow.engine.compute.Compute.min_memory_gb_per_worker","text":"","title":"min_memory_gb_per_worker"},{"location":"api/compute/#brickflow.engine.compute.Compute.ml","text":"","title":"ml"},{"location":"api/compute/#brickflow.engine.compute.Compute.photon","text":"","title":"photon"},{"location":"api/compute/#brickflow.engine.compute.Compute.photon_driver","text":"","title":"photon_driver"},{"location":"api/compute/#brickflow.engine.compute.Compute.photon_worker","text":"","title":"photon_worker"},{"location":"api/compute/#brickflow.engine.compute.Compute.spark_version","text":"","title":"spark_version"},{"location":"api/compute/#brickflow.engine.compute.Compute.support_port_forwarding","text":"","title":"support_port_forwarding"},{"location":"api/compute/#brickflow.engine.compute.Compute-functions","text":"","title":"Functions"},{"location":"api/compute/#brickflow.engine.compute.Compute.set_to_default","text":"Source code in brickflow/engine/compute.py 82 83 def set_to_default ( self ) -> None : self . compute_id = \"default\"","title":"set_to_default()"},{"location":"api/context/","text":"Attributes \u00b6 brickflow . context . ctx = Context () module-attribute \u00b6 Classes \u00b6 brickflow . context . Context () -> None \u00b6 Source code in brickflow/context/context.py 144 145 146 147 148 149 150 151 def __init__ ( self ) -> None : # Order of init matters todo: fix this self . _dbutils : Optional [ Any ] = None self . _spark : Optional [ Any ] = None self . _task_coms : BrickflowTaskComs self . _current_task : Optional [ str ] = None self . _configure () Functions \u00b6 current_task () -> Optional [ str ] property \u00b6 Source code in brickflow/context/context.py 164 165 166 @property def current_task ( self ) -> Optional [ str ]: return self . _current_task dbutils () -> DBUtils property \u00b6 Source code in brickflow/context/context.py 225 226 227 @property def dbutils ( self ) -> \"DBUtils\" : # type: ignore # noqa return self . _dbutils dbutils_widget_get_or_else ( key : str , debug : Optional [ str ]) -> Optional [ str ] \u00b6 Source code in brickflow/context/context.py 233 234 235 236 237 238 239 240 def dbutils_widget_get_or_else ( self , key : str , debug : Optional [ str ] ) -> Optional [ str ]: try : return self . dbutils . widgets . get ( key ) except Exception : # todo: log error return debug get_return_value ( task_key : Union [ str , Callable ]) -> Any \u00b6 Source code in brickflow/context/context.py 174 175 176 def get_return_value ( self , task_key : Union [ str , Callable ]) -> Any : task_key = task_key . __name__ if callable ( task_key ) else task_key return self . task_coms . get ( task_key , RETURN_VALUE_KEY ) job_id ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 209 210 211 @bind_variable ( BrickflowBuiltInTaskVariables . job_id ) def job_id ( self , * , debug : Optional [ str ]) -> str : pass parent_run_id ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 213 214 215 @bind_variable ( BrickflowBuiltInTaskVariables . parent_run_id ) def parent_run_id ( self , * , debug : Optional [ str ]) -> str : pass run_id ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 205 206 207 @bind_variable ( BrickflowBuiltInTaskVariables . run_id ) def run_id ( self , * , debug : Optional [ str ]) -> str : pass skip_all_except ( branch_task : Union [ Callable , str ]) -> None \u00b6 Source code in brickflow/context/context.py 178 179 180 181 182 183 184 185 186 def skip_all_except ( self , branch_task : Union [ Callable , str ]) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) branch_task_key = ( branch_task . __name__ if callable ( branch_task ) and hasattr ( branch_task , \"__name__\" ) is True else branch_task ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , branch_task_key ) skip_all_following () -> None \u00b6 Source code in brickflow/context/context.py 188 189 190 191 def skip_all_following ( self ) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK ) spark () -> SparkSession property \u00b6 Source code in brickflow/context/context.py 229 230 231 @property def spark ( self ) -> \"SparkSession\" : # type: ignore # noqa return self . _spark start_date ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 217 218 219 @bind_variable ( BrickflowBuiltInTaskVariables . start_date ) def start_date ( self , * , debug : Optional [ str ]) -> str : pass start_time ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 221 222 223 @bind_variable ( BrickflowBuiltInTaskVariables . start_time ) def start_time ( self , * , debug : Optional [ str ]) -> str : pass task_coms () -> BrickflowTaskComs property \u00b6 Source code in brickflow/context/context.py 193 194 195 @property def task_coms ( self ) -> BrickflowTaskComs : return self . _task_coms task_key ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 197 198 199 @bind_variable ( BrickflowBuiltInTaskVariables . task_key ) def task_key ( self , * , debug : Optional [ str ]) -> str : pass task_retry_count ( * , debug : Optional [ str ]) -> str \u00b6 Source code in brickflow/context/context.py 201 202 203 @bind_variable ( BrickflowBuiltInTaskVariables . task_retry_count ) def task_retry_count ( self , * , debug : Optional [ str ]) -> str : pass","title":"Context"},{"location":"api/context/#brickflow.context-attributes","text":"","title":"Attributes"},{"location":"api/context/#brickflow.context.ctx","text":"","title":"ctx"},{"location":"api/context/#brickflow.context-classes","text":"","title":"Classes"},{"location":"api/context/#brickflow.context.Context","text":"Source code in brickflow/context/context.py 144 145 146 147 148 149 150 151 def __init__ ( self ) -> None : # Order of init matters todo: fix this self . _dbutils : Optional [ Any ] = None self . _spark : Optional [ Any ] = None self . _task_coms : BrickflowTaskComs self . _current_task : Optional [ str ] = None self . _configure ()","title":"Context"},{"location":"api/context/#brickflow.context.Context-functions","text":"","title":"Functions"},{"location":"api/context/#brickflow.context.context.Context.current_task","text":"Source code in brickflow/context/context.py 164 165 166 @property def current_task ( self ) -> Optional [ str ]: return self . _current_task","title":"current_task()"},{"location":"api/context/#brickflow.context.context.Context.dbutils","text":"Source code in brickflow/context/context.py 225 226 227 @property def dbutils ( self ) -> \"DBUtils\" : # type: ignore # noqa return self . _dbutils","title":"dbutils()"},{"location":"api/context/#brickflow.context.context.Context.dbutils_widget_get_or_else","text":"Source code in brickflow/context/context.py 233 234 235 236 237 238 239 240 def dbutils_widget_get_or_else ( self , key : str , debug : Optional [ str ] ) -> Optional [ str ]: try : return self . dbutils . widgets . get ( key ) except Exception : # todo: log error return debug","title":"dbutils_widget_get_or_else()"},{"location":"api/context/#brickflow.context.context.Context.get_return_value","text":"Source code in brickflow/context/context.py 174 175 176 def get_return_value ( self , task_key : Union [ str , Callable ]) -> Any : task_key = task_key . __name__ if callable ( task_key ) else task_key return self . task_coms . get ( task_key , RETURN_VALUE_KEY )","title":"get_return_value()"},{"location":"api/context/#brickflow.context.context.Context.job_id","text":"Source code in brickflow/context/context.py 209 210 211 @bind_variable ( BrickflowBuiltInTaskVariables . job_id ) def job_id ( self , * , debug : Optional [ str ]) -> str : pass","title":"job_id()"},{"location":"api/context/#brickflow.context.context.Context.parent_run_id","text":"Source code in brickflow/context/context.py 213 214 215 @bind_variable ( BrickflowBuiltInTaskVariables . parent_run_id ) def parent_run_id ( self , * , debug : Optional [ str ]) -> str : pass","title":"parent_run_id()"},{"location":"api/context/#brickflow.context.context.Context.run_id","text":"Source code in brickflow/context/context.py 205 206 207 @bind_variable ( BrickflowBuiltInTaskVariables . run_id ) def run_id ( self , * , debug : Optional [ str ]) -> str : pass","title":"run_id()"},{"location":"api/context/#brickflow.context.context.Context.skip_all_except","text":"Source code in brickflow/context/context.py 178 179 180 181 182 183 184 185 186 def skip_all_except ( self , branch_task : Union [ Callable , str ]) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) branch_task_key = ( branch_task . __name__ if callable ( branch_task ) and hasattr ( branch_task , \"__name__\" ) is True else branch_task ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , branch_task_key )","title":"skip_all_except()"},{"location":"api/context/#brickflow.context.context.Context.skip_all_following","text":"Source code in brickflow/context/context.py 188 189 190 191 def skip_all_following ( self ) -> None : if self . _current_task is None : raise RuntimeError ( \"Current task is empty unable to skip...\" ) self . _task_coms . put ( self . _current_task , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK )","title":"skip_all_following()"},{"location":"api/context/#brickflow.context.context.Context.spark","text":"Source code in brickflow/context/context.py 229 230 231 @property def spark ( self ) -> \"SparkSession\" : # type: ignore # noqa return self . _spark","title":"spark()"},{"location":"api/context/#brickflow.context.context.Context.start_date","text":"Source code in brickflow/context/context.py 217 218 219 @bind_variable ( BrickflowBuiltInTaskVariables . start_date ) def start_date ( self , * , debug : Optional [ str ]) -> str : pass","title":"start_date()"},{"location":"api/context/#brickflow.context.context.Context.start_time","text":"Source code in brickflow/context/context.py 221 222 223 @bind_variable ( BrickflowBuiltInTaskVariables . start_time ) def start_time ( self , * , debug : Optional [ str ]) -> str : pass","title":"start_time()"},{"location":"api/context/#brickflow.context.context.Context.task_coms","text":"Source code in brickflow/context/context.py 193 194 195 @property def task_coms ( self ) -> BrickflowTaskComs : return self . _task_coms","title":"task_coms()"},{"location":"api/context/#brickflow.context.context.Context.task_key","text":"Source code in brickflow/context/context.py 197 198 199 @bind_variable ( BrickflowBuiltInTaskVariables . task_key ) def task_key ( self , * , debug : Optional [ str ]) -> str : pass","title":"task_key()"},{"location":"api/context/#brickflow.context.context.Context.task_retry_count","text":"Source code in brickflow/context/context.py 201 202 203 @bind_variable ( BrickflowBuiltInTaskVariables . task_retry_count ) def task_retry_count ( self , * , debug : Optional [ str ]) -> str : pass","title":"task_retry_count()"},{"location":"api/misc/","text":"","title":"Misc"},{"location":"api/project/","text":"Classes \u00b6 brickflow.engine.project.Project dataclass \u00b6 Attributes \u00b6 debug_execute_task : Optional [ str ] = None class-attribute \u00b6 debug_execute_workflow : Optional [ str ] = None class-attribute \u00b6 entry_point_path : Optional [ str ] = None class-attribute \u00b6 git_reference : Optional [ str ] = None class-attribute \u00b6 git_repo : Optional [ str ] = None class-attribute \u00b6 mode : Optional [ str ] = None class-attribute \u00b6 name : str = attr . field ( on_setattr = attr . setters . frozen ) class-attribute \u00b6 provider : Optional [ str ] = None class-attribute \u00b6 s3_backend : Optional [ str ] = None class-attribute \u00b6 Functions \u00b6 __enter__ () -> _Project \u00b6 Source code in brickflow/engine/project.py 234 235 236 237 238 239 240 241 242 def __enter__ ( self ) -> \"_Project\" : self . _project = _Project ( self . git_repo , self . provider , self . git_reference , self . s3_backend , self . entry_point_path , ) return self . _project __exit__ ( exc_type , exc_val , exc_tb ) -> None \u00b6 Source code in brickflow/engine/project.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def __exit__ ( self , exc_type , exc_val , exc_tb ) -> None : # type: ignore if exc_type is not None : raise exc_type if self . _mode . value == Stage . deploy . value : # local import to avoid node req from cdktf import App app = App () self . _project . generate_tf ( app , self . name , ) app . synth () if self . _mode . value == Stage . execute . value : wf_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . workflow_id . value , self . debug_execute_workflow , ) t_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . task_id . value , self . debug_execute_task ) workflow = self . _project . get_workflow ( wf_id ) task = workflow . get_task ( t_id ) task . execute () __post_init__ () -> None \u00b6 Source code in brickflow/engine/project.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def __post_init__ ( self ) -> None : self . _mode = Stage [ config ( BrickFlowEnvVars . BRICKFLOW_MODE . value , default = Stage . execute . value ) ] self . entry_point_path = self . entry_point_path or get_caller_info () if self . _mode == Stage . deploy : git_ref_default = ( self . git_reference if self . git_reference is not None else f \"commit/ { get_current_commit () } \" ) else : git_ref_default = ( self . git_reference if self . git_reference is not None else \"\" ) self . git_reference = config ( BrickFlowEnvVars . BRICKFLOW_GIT_REF . value , default = git_ref_default ) self . provider = config ( BrickFlowEnvVars . BRICKFLOW_GIT_PROVIDER . value , default = self . provider ) self . git_repo = config ( BrickFlowEnvVars . BRICKFLOW_GIT_REPO . value , default = self . git_repo ) brickflow.engine.project.BrickFlowEnvVars \u00b6 Bases: Enum Attributes \u00b6 BRICKFLOW_FORCE_DEPLOY = 'BRICKFLOW_FORCE_DEPLOY' class-attribute \u00b6 BRICKFLOW_GIT_PROVIDER = 'BRICKFLOW_GIT_PROVIDER' class-attribute \u00b6 BRICKFLOW_GIT_REF = 'BRICKFLOW_GIT_REF' class-attribute \u00b6 BRICKFLOW_GIT_REPO = 'BRICKFLOW_GIT_REPO' class-attribute \u00b6 BRICKFLOW_MODE = 'BRICKFLOW_MODE' class-attribute \u00b6","title":"Project"},{"location":"api/project/#brickflow.engine.project-classes","text":"","title":"Classes"},{"location":"api/project/#brickflow.engine.project.Project","text":"","title":"Project"},{"location":"api/project/#brickflow.engine.project.Project-attributes","text":"","title":"Attributes"},{"location":"api/project/#brickflow.engine.project.Project.debug_execute_task","text":"","title":"debug_execute_task"},{"location":"api/project/#brickflow.engine.project.Project.debug_execute_workflow","text":"","title":"debug_execute_workflow"},{"location":"api/project/#brickflow.engine.project.Project.entry_point_path","text":"","title":"entry_point_path"},{"location":"api/project/#brickflow.engine.project.Project.git_reference","text":"","title":"git_reference"},{"location":"api/project/#brickflow.engine.project.Project.git_repo","text":"","title":"git_repo"},{"location":"api/project/#brickflow.engine.project.Project.mode","text":"","title":"mode"},{"location":"api/project/#brickflow.engine.project.Project.name","text":"","title":"name"},{"location":"api/project/#brickflow.engine.project.Project.provider","text":"","title":"provider"},{"location":"api/project/#brickflow.engine.project.Project.s3_backend","text":"","title":"s3_backend"},{"location":"api/project/#brickflow.engine.project.Project-functions","text":"","title":"Functions"},{"location":"api/project/#brickflow.engine.project.Project.__enter__","text":"Source code in brickflow/engine/project.py 234 235 236 237 238 239 240 241 242 def __enter__ ( self ) -> \"_Project\" : self . _project = _Project ( self . git_repo , self . provider , self . git_reference , self . s3_backend , self . entry_point_path , ) return self . _project","title":"__enter__()"},{"location":"api/project/#brickflow.engine.project.Project.__exit__","text":"Source code in brickflow/engine/project.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def __exit__ ( self , exc_type , exc_val , exc_tb ) -> None : # type: ignore if exc_type is not None : raise exc_type if self . _mode . value == Stage . deploy . value : # local import to avoid node req from cdktf import App app = App () self . _project . generate_tf ( app , self . name , ) app . synth () if self . _mode . value == Stage . execute . value : wf_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . workflow_id . value , self . debug_execute_workflow , ) t_id = ctx . dbutils_widget_get_or_else ( BrickflowInternalVariables . task_id . value , self . debug_execute_task ) workflow = self . _project . get_workflow ( wf_id ) task = workflow . get_task ( t_id ) task . execute ()","title":"__exit__()"},{"location":"api/project/#brickflow.engine.project.Project.__post_init__","text":"Source code in brickflow/engine/project.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def __post_init__ ( self ) -> None : self . _mode = Stage [ config ( BrickFlowEnvVars . BRICKFLOW_MODE . value , default = Stage . execute . value ) ] self . entry_point_path = self . entry_point_path or get_caller_info () if self . _mode == Stage . deploy : git_ref_default = ( self . git_reference if self . git_reference is not None else f \"commit/ { get_current_commit () } \" ) else : git_ref_default = ( self . git_reference if self . git_reference is not None else \"\" ) self . git_reference = config ( BrickFlowEnvVars . BRICKFLOW_GIT_REF . value , default = git_ref_default ) self . provider = config ( BrickFlowEnvVars . BRICKFLOW_GIT_PROVIDER . value , default = self . provider ) self . git_repo = config ( BrickFlowEnvVars . BRICKFLOW_GIT_REPO . value , default = self . git_repo )","title":"__post_init__()"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars","text":"Bases: Enum","title":"BrickFlowEnvVars"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars-attributes","text":"","title":"Attributes"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars.BRICKFLOW_FORCE_DEPLOY","text":"","title":"BRICKFLOW_FORCE_DEPLOY"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars.BRICKFLOW_GIT_PROVIDER","text":"","title":"BRICKFLOW_GIT_PROVIDER"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars.BRICKFLOW_GIT_REF","text":"","title":"BRICKFLOW_GIT_REF"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars.BRICKFLOW_GIT_REPO","text":"","title":"BRICKFLOW_GIT_REPO"},{"location":"api/project/#brickflow.engine.project.BrickFlowEnvVars.BRICKFLOW_MODE","text":"","title":"BRICKFLOW_MODE"},{"location":"api/task/","text":"Classes \u00b6 brickflow.engine.task.Task dataclass \u00b6 Attributes \u00b6 compute : Optional [ Compute ] = None class-attribute \u00b6 custom_execute_callback : Optional [ Callable ] = None class-attribute \u00b6 depends_on : List [ Union [ Callable , str ]] = field ( default_factory = lambda : []) class-attribute \u00b6 description : Optional [ str ] = None class-attribute \u00b6 task_func : Callable class-attribute \u00b6 task_id : str class-attribute \u00b6 task_settings : Optional [ TaskSettings ] = None class-attribute \u00b6 task_type : TaskType = TaskType . NOTEBOOK class-attribute \u00b6 trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS class-attribute \u00b6 workflow : Workflow class-attribute \u00b6 Functions \u00b6 brickflow_default_params () -> Dict [ str , str ] property \u00b6 Source code in brickflow/engine/task.py 166 167 168 169 170 171 172 173 @property def brickflow_default_params ( self ) -> Dict [ str , str ]: return { BrickflowInternalVariables . workflow_id . value : self . workflow . name , # 2 braces to escape 1 BrickflowInternalVariables . task_id . value : f \" {{{{ { BrickflowBuiltInTaskVariables . task_key . name } }}}} \" , BrickflowInternalVariables . only_run_tasks . value : \"\" , } builtin_notebook_params () -> Dict [ str , str ] property \u00b6 Source code in brickflow/engine/task.py 157 158 159 160 @property def builtin_notebook_params ( self ) -> Dict [ str , str ]: # 2 braces to escape for 1 return { i . value : f \" {{{{ { i . name } }}}} \" for i in BrickflowBuiltInTaskVariables } custom_task_parameters () -> Dict [ str , Union [ str , None , numbers . Number ]] property \u00b6 Source code in brickflow/engine/task.py 213 214 215 216 217 218 @property def custom_task_parameters ( self ) -> Dict [ str , Union [ str , None , numbers . Number ]]: spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) if spec . kwonlydefaults is None : return {} return { k : str ( v ) for k , v in spec . kwonlydefaults . items ()} execute () -> Any \u00b6 Source code in brickflow/engine/task.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 @with_brickflow_logger def execute ( self ) -> Any : # Workflow is: # 1. Check to see if there selected tasks and if there are is this task in the list # 2. Check to see if the previous task is skipped and trigger rule. # 3. Check to see if this a custom python task and execute it # 4. Execute the task function ctx . _set_current_task ( self . name ) _select_task_skip , _select_task_skip_reason = self . _skip_because_not_selected () if _select_task_skip is True : # check if this task is skipped due to task selection logging . info ( \"Skipping task... %s for reason: %s \" , self . name , _select_task_skip_reason , ) ctx . _reset_current_task () return _skip , reason = self . should_skip () if _skip is True : logging . info ( \"Skipping task... %s for reason: %s \" , self . name , reason ) ctx . task_coms . put ( self . name , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK ) ctx . _reset_current_task () return return_value = TaskComsObjectResult . NO_RESULTS if ( self . task_type == TaskType . CUSTOM_PYTHON_TASK and self . custom_execute_callback is not None ): resp : CustomTaskResponse = self . custom_execute_callback ( self ) if resp . push_return_value is True : return_value = resp . response else : # TODO: Inject context object return_value = self . task_func () ctx . task_coms . put ( self . name , RETURN_VALUE_KEY , return_value ) ctx . _reset_current_task () return return_value get_tf_obj ( entrypoint ) -> JobTaskNotebookTask \u00b6 Source code in brickflow/engine/task.py 175 176 177 178 179 180 181 182 183 184 185 186 def get_tf_obj ( self , entrypoint ) -> \"JobTaskNotebookTask\" : # type: ignore # noqa from brickflow.tf.databricks import JobTaskNotebookTask if self . task_type in [ TaskType . NOTEBOOK , TaskType . CUSTOM_PYTHON_TASK ]: return JobTaskNotebookTask ( notebook_path = entrypoint , base_parameters = { ** self . builtin_notebook_params , ** self . brickflow_default_params , ** ( self . custom_task_parameters or {}), # type: ignore }, ) is_valid_task_signature () -> None \u00b6 Source code in brickflow/engine/task.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def is_valid_task_signature ( self ) -> None : # only supports kwonlyargs with defaults spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) sig : inspect . Signature = inspect . signature ( self . task_func ) signature_error_msg = ( \"Task signatures only supports kwargs with defaults. or catch all varkw **kwargs\" \"For example def execute(*, variable_a=None, variable_b=None, **kwargs). \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) kwargs_default_error_msg = ( f \"Keyword arguments must be either None, String or number. \" f \"Please handle booleans via strings. \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) valid_case = spec . args == [] and spec . varargs is None and spec . defaults is None for _ , v in ( spec . kwonlydefaults or {}) . items (): if not ( isinstance ( v , ( numbers . Number , str )) or v is None ): raise InvalidTaskSignatureDefinition ( kwargs_default_error_msg ) if valid_case : return raise InvalidTaskSignatureDefinition ( signature_error_msg ) name () -> str property \u00b6 Source code in brickflow/engine/task.py 162 163 164 @property def name ( self ) -> str : return self . task_id parents () -> List [ str ] property \u00b6 Source code in brickflow/engine/task.py 149 150 151 @property def parents ( self ) -> List [ str ]: return list ( self . workflow . parents ( self . task_id )) should_skip () -> Tuple [ bool , Optional [ str ]] \u00b6 Source code in brickflow/engine/task.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def should_skip ( self ) -> Tuple [ bool , Optional [ str ]]: # return true or false and reason node_skip_checks = [] for parent in self . parents : if parent != ROOT_NODE : try : task_to_not_skip = ctx . task_coms . get ( parent , BRANCH_SKIP_EXCEPT ) if self . name != task_to_not_skip : # set this task to skip hack to keep to empty to trigger failure # key look up will fail node_skip_checks . append ( True ) else : node_skip_checks . append ( False ) except Exception : # ignore errors as it probably doesnt exist # TODO: log errors node_skip_checks . append ( False ) if not node_skip_checks : return False , None if self . trigger_rule == BrickflowTriggerRule . NONE_FAILED : # by default a task failure automatically skips return self . _get_skip_with_reason ( all ( node_skip_checks ), \"At least one task before this were not successful\" , ) # default is BrickflowTriggerRule.ALL_SUCCESS return self . _get_skip_with_reason ( any ( node_skip_checks ), \"All tasks before this were not successful\" ) task_func_name () -> str property \u00b6 Source code in brickflow/engine/task.py 145 146 147 @property def task_func_name ( self ) -> str : return self . task_func . __name__ task_type_str () -> str property \u00b6 Source code in brickflow/engine/task.py 153 154 155 @property def task_type_str ( self ) -> str : return self . task_type . value brickflow.engine.task.EmailNotifications dataclass \u00b6 Attributes \u00b6 on_failure : Optional [ List [ str ]] = None class-attribute \u00b6 on_start : Optional [ List [ str ]] = None class-attribute \u00b6 on_success : Optional [ List [ str ]] = None class-attribute \u00b6 Functions \u00b6 to_tf_dict () -> Dict [ str , Optional [ List [ str ]]] \u00b6 Source code in brickflow/engine/task.py 72 73 74 75 76 77 def to_tf_dict ( self ) -> Dict [ str , Optional [ List [ str ]]]: return { \"on_start\" : self . on_start , \"on_failure\" : self . on_failure , \"on_success\" : self . on_success , } brickflow.engine.task.BrickflowTriggerRule \u00b6 Bases: Enum Attributes \u00b6 ALL_SUCCESS = 'all_success' class-attribute \u00b6 NONE_FAILED = 'none_failed' class-attribute \u00b6 brickflow.engine.task.BrickflowTaskEnvVars \u00b6 Bases: Enum Attributes \u00b6 BRICKFLOW_SELECT_TASKS = 'BRICKFLOW_SELECT_TASKS' class-attribute \u00b6 brickflow.engine.task.TaskSettings dataclass \u00b6 Attributes \u00b6 email_notifications : Optional [ EmailNotifications ] = None class-attribute \u00b6 max_retries : Optional [ int ] = None class-attribute \u00b6 min_retry_interval_millis : Optional [ int ] = None class-attribute \u00b6 retry_on_timeout : Optional [ bool ] = None class-attribute \u00b6 timeout_seconds : Optional [ int ] = None class-attribute \u00b6 Functions \u00b6 merge ( other : Optional [ TaskSettings ]) -> TaskSettings \u00b6 Source code in brickflow/engine/task.py 88 89 90 91 92 93 94 95 96 97 98 def merge ( self , other : Optional [ \"TaskSettings\" ]) -> \"TaskSettings\" : # overrides top level values if other is None : return self return TaskSettings ( other . email_notifications or self . email_notifications , other . timeout_seconds or self . timeout_seconds or 0 , other . max_retries or self . max_retries , other . min_retry_interval_millis or self . min_retry_interval_millis , other . retry_on_timeout or self . retry_on_timeout , ) to_tf_dict () -> Dict [ str , Optional [ str ] | Optional [ int ] | Optional [ bool ] | Optional [ Dict [ str , Optional [ List [ str ]]]]] \u00b6 Source code in brickflow/engine/task.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def to_tf_dict ( self , ) -> Dict [ str , Optional [ str ] | Optional [ int ] | Optional [ bool ] | Optional [ Dict [ str , Optional [ List [ str ]]]], ]: email_not = ( self . email_notifications . to_tf_dict () if self . email_notifications is not None else {} ) return { \"email_notifications\" : email_not , \"timeout_seconds\" : self . timeout_seconds , \"max_retries\" : self . max_retries , \"min_retry_interval_millis\" : self . min_retry_interval_millis , \"retry_on_timeout\" : self . retry_on_timeout , } brickflow.engine.task.TaskType \u00b6 Bases: Enum Attributes \u00b6 CUSTOM_PYTHON_TASK = 'custom_python_task' class-attribute \u00b6 NOTEBOOK = 'notebook_task' class-attribute \u00b6 SQL = 'sql_task' class-attribute \u00b6","title":"Task"},{"location":"api/task/#brickflow.engine.task-classes","text":"","title":"Classes"},{"location":"api/task/#brickflow.engine.task.Task","text":"","title":"Task"},{"location":"api/task/#brickflow.engine.task.Task-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.Task.compute","text":"","title":"compute"},{"location":"api/task/#brickflow.engine.task.Task.custom_execute_callback","text":"","title":"custom_execute_callback"},{"location":"api/task/#brickflow.engine.task.Task.depends_on","text":"","title":"depends_on"},{"location":"api/task/#brickflow.engine.task.Task.description","text":"","title":"description"},{"location":"api/task/#brickflow.engine.task.Task.task_func","text":"","title":"task_func"},{"location":"api/task/#brickflow.engine.task.Task.task_id","text":"","title":"task_id"},{"location":"api/task/#brickflow.engine.task.Task.task_settings","text":"","title":"task_settings"},{"location":"api/task/#brickflow.engine.task.Task.task_type","text":"","title":"task_type"},{"location":"api/task/#brickflow.engine.task.Task.trigger_rule","text":"","title":"trigger_rule"},{"location":"api/task/#brickflow.engine.task.Task.workflow","text":"","title":"workflow"},{"location":"api/task/#brickflow.engine.task.Task-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.Task.brickflow_default_params","text":"Source code in brickflow/engine/task.py 166 167 168 169 170 171 172 173 @property def brickflow_default_params ( self ) -> Dict [ str , str ]: return { BrickflowInternalVariables . workflow_id . value : self . workflow . name , # 2 braces to escape 1 BrickflowInternalVariables . task_id . value : f \" {{{{ { BrickflowBuiltInTaskVariables . task_key . name } }}}} \" , BrickflowInternalVariables . only_run_tasks . value : \"\" , }","title":"brickflow_default_params()"},{"location":"api/task/#brickflow.engine.task.Task.builtin_notebook_params","text":"Source code in brickflow/engine/task.py 157 158 159 160 @property def builtin_notebook_params ( self ) -> Dict [ str , str ]: # 2 braces to escape for 1 return { i . value : f \" {{{{ { i . name } }}}} \" for i in BrickflowBuiltInTaskVariables }","title":"builtin_notebook_params()"},{"location":"api/task/#brickflow.engine.task.Task.custom_task_parameters","text":"Source code in brickflow/engine/task.py 213 214 215 216 217 218 @property def custom_task_parameters ( self ) -> Dict [ str , Union [ str , None , numbers . Number ]]: spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) if spec . kwonlydefaults is None : return {} return { k : str ( v ) for k , v in spec . kwonlydefaults . items ()}","title":"custom_task_parameters()"},{"location":"api/task/#brickflow.engine.task.Task.execute","text":"Source code in brickflow/engine/task.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 @with_brickflow_logger def execute ( self ) -> Any : # Workflow is: # 1. Check to see if there selected tasks and if there are is this task in the list # 2. Check to see if the previous task is skipped and trigger rule. # 3. Check to see if this a custom python task and execute it # 4. Execute the task function ctx . _set_current_task ( self . name ) _select_task_skip , _select_task_skip_reason = self . _skip_because_not_selected () if _select_task_skip is True : # check if this task is skipped due to task selection logging . info ( \"Skipping task... %s for reason: %s \" , self . name , _select_task_skip_reason , ) ctx . _reset_current_task () return _skip , reason = self . should_skip () if _skip is True : logging . info ( \"Skipping task... %s for reason: %s \" , self . name , reason ) ctx . task_coms . put ( self . name , BRANCH_SKIP_EXCEPT , SKIP_EXCEPT_HACK ) ctx . _reset_current_task () return return_value = TaskComsObjectResult . NO_RESULTS if ( self . task_type == TaskType . CUSTOM_PYTHON_TASK and self . custom_execute_callback is not None ): resp : CustomTaskResponse = self . custom_execute_callback ( self ) if resp . push_return_value is True : return_value = resp . response else : # TODO: Inject context object return_value = self . task_func () ctx . task_coms . put ( self . name , RETURN_VALUE_KEY , return_value ) ctx . _reset_current_task () return return_value","title":"execute()"},{"location":"api/task/#brickflow.engine.task.Task.get_tf_obj","text":"Source code in brickflow/engine/task.py 175 176 177 178 179 180 181 182 183 184 185 186 def get_tf_obj ( self , entrypoint ) -> \"JobTaskNotebookTask\" : # type: ignore # noqa from brickflow.tf.databricks import JobTaskNotebookTask if self . task_type in [ TaskType . NOTEBOOK , TaskType . CUSTOM_PYTHON_TASK ]: return JobTaskNotebookTask ( notebook_path = entrypoint , base_parameters = { ** self . builtin_notebook_params , ** self . brickflow_default_params , ** ( self . custom_task_parameters or {}), # type: ignore }, )","title":"get_tf_obj()"},{"location":"api/task/#brickflow.engine.task.Task.is_valid_task_signature","text":"Source code in brickflow/engine/task.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def is_valid_task_signature ( self ) -> None : # only supports kwonlyargs with defaults spec : inspect . FullArgSpec = inspect . getfullargspec ( self . task_func ) sig : inspect . Signature = inspect . signature ( self . task_func ) signature_error_msg = ( \"Task signatures only supports kwargs with defaults. or catch all varkw **kwargs\" \"For example def execute(*, variable_a=None, variable_b=None, **kwargs). \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) kwargs_default_error_msg = ( f \"Keyword arguments must be either None, String or number. \" f \"Please handle booleans via strings. \" f \"Please fix function def { self . task_func_name }{ sig } : ...\" ) valid_case = spec . args == [] and spec . varargs is None and spec . defaults is None for _ , v in ( spec . kwonlydefaults or {}) . items (): if not ( isinstance ( v , ( numbers . Number , str )) or v is None ): raise InvalidTaskSignatureDefinition ( kwargs_default_error_msg ) if valid_case : return raise InvalidTaskSignatureDefinition ( signature_error_msg )","title":"is_valid_task_signature()"},{"location":"api/task/#brickflow.engine.task.Task.name","text":"Source code in brickflow/engine/task.py 162 163 164 @property def name ( self ) -> str : return self . task_id","title":"name()"},{"location":"api/task/#brickflow.engine.task.Task.parents","text":"Source code in brickflow/engine/task.py 149 150 151 @property def parents ( self ) -> List [ str ]: return list ( self . workflow . parents ( self . task_id ))","title":"parents()"},{"location":"api/task/#brickflow.engine.task.Task.should_skip","text":"Source code in brickflow/engine/task.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def should_skip ( self ) -> Tuple [ bool , Optional [ str ]]: # return true or false and reason node_skip_checks = [] for parent in self . parents : if parent != ROOT_NODE : try : task_to_not_skip = ctx . task_coms . get ( parent , BRANCH_SKIP_EXCEPT ) if self . name != task_to_not_skip : # set this task to skip hack to keep to empty to trigger failure # key look up will fail node_skip_checks . append ( True ) else : node_skip_checks . append ( False ) except Exception : # ignore errors as it probably doesnt exist # TODO: log errors node_skip_checks . append ( False ) if not node_skip_checks : return False , None if self . trigger_rule == BrickflowTriggerRule . NONE_FAILED : # by default a task failure automatically skips return self . _get_skip_with_reason ( all ( node_skip_checks ), \"At least one task before this were not successful\" , ) # default is BrickflowTriggerRule.ALL_SUCCESS return self . _get_skip_with_reason ( any ( node_skip_checks ), \"All tasks before this were not successful\" )","title":"should_skip()"},{"location":"api/task/#brickflow.engine.task.Task.task_func_name","text":"Source code in brickflow/engine/task.py 145 146 147 @property def task_func_name ( self ) -> str : return self . task_func . __name__","title":"task_func_name()"},{"location":"api/task/#brickflow.engine.task.Task.task_type_str","text":"Source code in brickflow/engine/task.py 153 154 155 @property def task_type_str ( self ) -> str : return self . task_type . value","title":"task_type_str()"},{"location":"api/task/#brickflow.engine.task.EmailNotifications","text":"","title":"EmailNotifications"},{"location":"api/task/#brickflow.engine.task.EmailNotifications-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.on_failure","text":"","title":"on_failure"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.on_start","text":"","title":"on_start"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.on_success","text":"","title":"on_success"},{"location":"api/task/#brickflow.engine.task.EmailNotifications-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.EmailNotifications.to_tf_dict","text":"Source code in brickflow/engine/task.py 72 73 74 75 76 77 def to_tf_dict ( self ) -> Dict [ str , Optional [ List [ str ]]]: return { \"on_start\" : self . on_start , \"on_failure\" : self . on_failure , \"on_success\" : self . on_success , }","title":"to_tf_dict()"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule","text":"Bases: Enum","title":"BrickflowTriggerRule"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule.ALL_SUCCESS","text":"","title":"ALL_SUCCESS"},{"location":"api/task/#brickflow.engine.task.BrickflowTriggerRule.NONE_FAILED","text":"","title":"NONE_FAILED"},{"location":"api/task/#brickflow.engine.task.BrickflowTaskEnvVars","text":"Bases: Enum","title":"BrickflowTaskEnvVars"},{"location":"api/task/#brickflow.engine.task.BrickflowTaskEnvVars-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.BrickflowTaskEnvVars.BRICKFLOW_SELECT_TASKS","text":"","title":"BRICKFLOW_SELECT_TASKS"},{"location":"api/task/#brickflow.engine.task.TaskSettings","text":"","title":"TaskSettings"},{"location":"api/task/#brickflow.engine.task.TaskSettings-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.TaskSettings.email_notifications","text":"","title":"email_notifications"},{"location":"api/task/#brickflow.engine.task.TaskSettings.max_retries","text":"","title":"max_retries"},{"location":"api/task/#brickflow.engine.task.TaskSettings.min_retry_interval_millis","text":"","title":"min_retry_interval_millis"},{"location":"api/task/#brickflow.engine.task.TaskSettings.retry_on_timeout","text":"","title":"retry_on_timeout"},{"location":"api/task/#brickflow.engine.task.TaskSettings.timeout_seconds","text":"","title":"timeout_seconds"},{"location":"api/task/#brickflow.engine.task.TaskSettings-functions","text":"","title":"Functions"},{"location":"api/task/#brickflow.engine.task.TaskSettings.merge","text":"Source code in brickflow/engine/task.py 88 89 90 91 92 93 94 95 96 97 98 def merge ( self , other : Optional [ \"TaskSettings\" ]) -> \"TaskSettings\" : # overrides top level values if other is None : return self return TaskSettings ( other . email_notifications or self . email_notifications , other . timeout_seconds or self . timeout_seconds or 0 , other . max_retries or self . max_retries , other . min_retry_interval_millis or self . min_retry_interval_millis , other . retry_on_timeout or self . retry_on_timeout , )","title":"merge()"},{"location":"api/task/#brickflow.engine.task.TaskSettings.to_tf_dict","text":"Source code in brickflow/engine/task.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def to_tf_dict ( self , ) -> Dict [ str , Optional [ str ] | Optional [ int ] | Optional [ bool ] | Optional [ Dict [ str , Optional [ List [ str ]]]], ]: email_not = ( self . email_notifications . to_tf_dict () if self . email_notifications is not None else {} ) return { \"email_notifications\" : email_not , \"timeout_seconds\" : self . timeout_seconds , \"max_retries\" : self . max_retries , \"min_retry_interval_millis\" : self . min_retry_interval_millis , \"retry_on_timeout\" : self . retry_on_timeout , }","title":"to_tf_dict()"},{"location":"api/task/#brickflow.engine.task.TaskType","text":"Bases: Enum","title":"TaskType"},{"location":"api/task/#brickflow.engine.task.TaskType-attributes","text":"","title":"Attributes"},{"location":"api/task/#brickflow.engine.task.TaskType.CUSTOM_PYTHON_TASK","text":"","title":"CUSTOM_PYTHON_TASK"},{"location":"api/task/#brickflow.engine.task.TaskType.NOTEBOOK","text":"","title":"NOTEBOOK"},{"location":"api/task/#brickflow.engine.task.TaskType.SQL","text":"","title":"SQL"},{"location":"api/workflow/","text":"Classes \u00b6 brickflow.engine.workflow.Workflow dataclass \u00b6 Attributes \u00b6 active_task : Optional [ str ] = None class-attribute \u00b6 compute : Dict [ str , Compute ] = field ( default_factory = lambda : {}) class-attribute \u00b6 default_compute : Compute = Compute ( compute_id = 'default' ) class-attribute \u00b6 default_task_settings : TaskSettings = TaskSettings () class-attribute \u00b6 existing_cluster_id : Optional [ str ] = None class-attribute \u00b6 graph : nx . DiGraph = nx . DiGraph () class-attribute \u00b6 max_concurrent_runs : int = 1 class-attribute \u00b6 name : str = attr . field ( on_setattr = attr . setters . frozen ) class-attribute \u00b6 permissions : WorkflowPermissions = WorkflowPermissions () class-attribute \u00b6 tags : Optional [ Dict [ str , str ]] = None class-attribute \u00b6 tasks : Dict [ str , Task ] = field ( default_factory = lambda : {}) class-attribute \u00b6 Functions \u00b6 bfs_layers () -> List [ str ] property \u00b6 Source code in brickflow/engine/workflow.py 99 100 101 @property def bfs_layers ( self ) -> List [ str ]: return list ( nx . bfs_layers ( self . graph , ROOT_NODE ))[ 1 :] bfs_task_iter () -> Iterator [ Task ] \u00b6 Source code in brickflow/engine/workflow.py 107 108 109 110 def bfs_task_iter ( self ) -> Iterator [ Task ]: for layer in self . bfs_layers : for task_key in layer : yield self . get_task ( task_key ) check_no_active_task () -> None \u00b6 Source code in brickflow/engine/workflow.py 115 116 117 118 119 120 def check_no_active_task ( self ) -> None : if self . active_task is not None : raise AnotherActiveTaskError ( \"You are calling another active task in another task. \" \"Please abstract the code more.\" ) get_task ( task_id : str ) -> Task \u00b6 Source code in brickflow/engine/workflow.py 122 123 124 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def get_task ( self , task_id : str ) -> Task : return self . tasks [ task_id ] parents ( node : str ) -> Iterator \u00b6 Source code in brickflow/engine/workflow.py 112 113 def parents ( self , node : str ) -> Iterator : return self . graph . predecessors ( node ) pop_task ( task_id : str ) -> None \u00b6 Source code in brickflow/engine/workflow.py 126 127 128 129 130 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def pop_task ( self , task_id : str ) -> None : # Pop from dict and graph self . tasks . pop ( task_id ) self . graph . remove_node ( task_id ) task ( task_func : Callable = None , name : str = None , compute : Optional [ Compute ] = None , task_type : TaskType = TaskType . NOTEBOOK , depends_on : Optional [ Union [ Callable , str , List [ Union [ Callable , str ]]]] = None , trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS , custom_execute_callback : Callable = None ) -> Callable \u00b6 Source code in brickflow/engine/workflow.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def task ( self , task_func : Callable = None , name : str = None , compute : Optional [ Compute ] = None , task_type : TaskType = TaskType . NOTEBOOK , depends_on : Optional [ Union [ Callable , str , List [ Union [ Callable , str ]]]] = None , trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS , custom_execute_callback : Callable = None , ) -> Callable : def task_wrapper ( f : Callable ) -> Callable : task_id = name or f . __name__ self . _add_task ( f , task_id , compute = compute , task_type = task_type , depends_on = depends_on , trigger_rule = trigger_rule , custom_execute_callback = custom_execute_callback , ) @functools . wraps ( f ) def func ( * args , ** kwargs ): # type: ignore try : self . check_no_active_task () self . _set_active_task ( task_id ) resp = f ( * args , ** kwargs ) return resp except Exception as e : self . _reset_active_task () raise e finally : self . _reset_active_task () return func if task_func is not None : if callable ( task_func ): return task_wrapper ( task_func ) else : raise NoCallableTaskError ( \"Please use task decorator against a callable function.\" ) return task_wrapper task_exists ( task_id : str ) -> bool \u00b6 Source code in brickflow/engine/workflow.py 132 133 def task_exists ( self , task_id : str ) -> bool : return task_id in self . tasks task_iter () -> Iterator [ Task ] \u00b6 Source code in brickflow/engine/workflow.py 103 104 105 def task_iter ( self ) -> Iterator [ Task ]: for task in self . bfs_task_iter (): yield task brickflow.engine.workflow.User \u00b6 Bases: ScimEntity Functions \u00b6 to_access_control () -> Dict [ str , str ] \u00b6 Source code in brickflow/engine/workflow.py 34 35 def to_access_control ( self ) -> Dict [ str , str ]: return { \"user_name\" : self . name } brickflow.engine.workflow.Group \u00b6 Bases: ScimEntity Functions \u00b6 to_access_control () -> Dict [ str , str ] \u00b6 Source code in brickflow/engine/workflow.py 39 40 def to_access_control ( self ) -> Dict [ str , str ]: return { \"group_name\" : self . name } brickflow.engine.workflow.ServicePrincipal \u00b6 Bases: ScimEntity Functions \u00b6 to_access_control () -> Dict [ str , str ] \u00b6 Source code in brickflow/engine/workflow.py 44 45 def to_access_control ( self ) -> Dict [ str , str ]: return { \"service_principal_name\" : self . name }","title":"Workflow"},{"location":"api/workflow/#brickflow.engine.workflow-classes","text":"","title":"Classes"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow","text":"","title":"Workflow"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow-attributes","text":"","title":"Attributes"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.active_task","text":"","title":"active_task"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.compute","text":"","title":"compute"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.default_compute","text":"","title":"default_compute"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.default_task_settings","text":"","title":"default_task_settings"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.existing_cluster_id","text":"","title":"existing_cluster_id"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.graph","text":"","title":"graph"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.max_concurrent_runs","text":"","title":"max_concurrent_runs"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.name","text":"","title":"name"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.permissions","text":"","title":"permissions"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.tags","text":"","title":"tags"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.tasks","text":"","title":"tasks"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.bfs_layers","text":"Source code in brickflow/engine/workflow.py 99 100 101 @property def bfs_layers ( self ) -> List [ str ]: return list ( nx . bfs_layers ( self . graph , ROOT_NODE ))[ 1 :]","title":"bfs_layers()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.bfs_task_iter","text":"Source code in brickflow/engine/workflow.py 107 108 109 110 def bfs_task_iter ( self ) -> Iterator [ Task ]: for layer in self . bfs_layers : for task_key in layer : yield self . get_task ( task_key )","title":"bfs_task_iter()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.check_no_active_task","text":"Source code in brickflow/engine/workflow.py 115 116 117 118 119 120 def check_no_active_task ( self ) -> None : if self . active_task is not None : raise AnotherActiveTaskError ( \"You are calling another active task in another task. \" \"Please abstract the code more.\" )","title":"check_no_active_task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.get_task","text":"Source code in brickflow/engine/workflow.py 122 123 124 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def get_task ( self , task_id : str ) -> Task : return self . tasks [ task_id ]","title":"get_task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.parents","text":"Source code in brickflow/engine/workflow.py 112 113 def parents ( self , node : str ) -> Iterator : return self . graph . predecessors ( node )","title":"parents()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.pop_task","text":"Source code in brickflow/engine/workflow.py 126 127 128 129 130 @wraps_keyerror ( TaskNotFoundError , \"Unable to find task: \" ) def pop_task ( self , task_id : str ) -> None : # Pop from dict and graph self . tasks . pop ( task_id ) self . graph . remove_node ( task_id )","title":"pop_task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.task","text":"Source code in brickflow/engine/workflow.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def task ( self , task_func : Callable = None , name : str = None , compute : Optional [ Compute ] = None , task_type : TaskType = TaskType . NOTEBOOK , depends_on : Optional [ Union [ Callable , str , List [ Union [ Callable , str ]]]] = None , trigger_rule : BrickflowTriggerRule = BrickflowTriggerRule . ALL_SUCCESS , custom_execute_callback : Callable = None , ) -> Callable : def task_wrapper ( f : Callable ) -> Callable : task_id = name or f . __name__ self . _add_task ( f , task_id , compute = compute , task_type = task_type , depends_on = depends_on , trigger_rule = trigger_rule , custom_execute_callback = custom_execute_callback , ) @functools . wraps ( f ) def func ( * args , ** kwargs ): # type: ignore try : self . check_no_active_task () self . _set_active_task ( task_id ) resp = f ( * args , ** kwargs ) return resp except Exception as e : self . _reset_active_task () raise e finally : self . _reset_active_task () return func if task_func is not None : if callable ( task_func ): return task_wrapper ( task_func ) else : raise NoCallableTaskError ( \"Please use task decorator against a callable function.\" ) return task_wrapper","title":"task()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.task_exists","text":"Source code in brickflow/engine/workflow.py 132 133 def task_exists ( self , task_id : str ) -> bool : return task_id in self . tasks","title":"task_exists()"},{"location":"api/workflow/#brickflow.engine.workflow.Workflow.task_iter","text":"Source code in brickflow/engine/workflow.py 103 104 105 def task_iter ( self ) -> Iterator [ Task ]: for task in self . bfs_task_iter (): yield task","title":"task_iter()"},{"location":"api/workflow/#brickflow.engine.workflow.User","text":"Bases: ScimEntity","title":"User"},{"location":"api/workflow/#brickflow.engine.workflow.User-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.User.to_access_control","text":"Source code in brickflow/engine/workflow.py 34 35 def to_access_control ( self ) -> Dict [ str , str ]: return { \"user_name\" : self . name }","title":"to_access_control()"},{"location":"api/workflow/#brickflow.engine.workflow.Group","text":"Bases: ScimEntity","title":"Group"},{"location":"api/workflow/#brickflow.engine.workflow.Group-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.Group.to_access_control","text":"Source code in brickflow/engine/workflow.py 39 40 def to_access_control ( self ) -> Dict [ str , str ]: return { \"group_name\" : self . name }","title":"to_access_control()"},{"location":"api/workflow/#brickflow.engine.workflow.ServicePrincipal","text":"Bases: ScimEntity","title":"ServicePrincipal"},{"location":"api/workflow/#brickflow.engine.workflow.ServicePrincipal-functions","text":"","title":"Functions"},{"location":"api/workflow/#brickflow.engine.workflow.ServicePrincipal.to_access_control","text":"Source code in brickflow/engine/workflow.py 44 45 def to_access_control ( self ) -> Dict [ str , str ]: return { \"service_principal_name\" : self . name }","title":"to_access_control()"},{"location":"cli/reference/","text":"This page provides documentation for our command line tools. brickflow \u00b6 CLI for managing Databricks Workflows Usage: brickflow [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. cdktf \u00b6 CLI for deploying workflow projects. Usage: brickflow cdktf [OPTIONS] Options: --help Show this message and exit. docs \u00b6 Use to open docs in your browser... Usage: brickflow docs [OPTIONS] Options: --help Show this message and exit. init \u00b6 Initialize your project with Brickflows... Usage: brickflow init [OPTIONS] Options: --help Show this message and exit. bf \u00b6 CLI for managing Databricks Workflows Usage: bf [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. cdktf \u00b6 CLI for deploying workflow projects. Usage: bf cdktf [OPTIONS] Options: --help Show this message and exit. docs \u00b6 Use to open docs in your browser... Usage: bf docs [OPTIONS] Options: --help Show this message and exit. init \u00b6 Initialize your project with Brickflows... Usage: bf init [OPTIONS] Options: --help Show this message and exit.","title":"Commands"},{"location":"cli/reference/#brickflow","text":"CLI for managing Databricks Workflows Usage: brickflow [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"brickflow"},{"location":"cli/reference/#cdktf","text":"CLI for deploying workflow projects. Usage: brickflow cdktf [OPTIONS] Options: --help Show this message and exit.","title":"cdktf"},{"location":"cli/reference/#docs","text":"Use to open docs in your browser... Usage: brickflow docs [OPTIONS] Options: --help Show this message and exit.","title":"docs"},{"location":"cli/reference/#init","text":"Initialize your project with Brickflows... Usage: brickflow init [OPTIONS] Options: --help Show this message and exit.","title":"init"},{"location":"cli/reference/#bf","text":"CLI for managing Databricks Workflows Usage: bf [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"bf"},{"location":"cli/reference/#cdktf_1","text":"CLI for deploying workflow projects. Usage: bf cdktf [OPTIONS] Options: --help Show this message and exit.","title":"cdktf"},{"location":"cli/reference/#docs_1","text":"Use to open docs in your browser... Usage: bf docs [OPTIONS] Options: --help Show this message and exit.","title":"docs"},{"location":"cli/reference/#init_1","text":"Initialize your project with Brickflows... Usage: bf init [OPTIONS] Options: --help Show this message and exit.","title":"init"},{"location":"examples/basic-00/","text":"","title":"Production Readiness Checklist"},{"location":"examples/basic-01/","text":"","title":"Basic Dag With Dependancies"},{"location":"examples/basic-02/","text":"","title":"Branching and then Join"},{"location":"examples/basic-03/","text":"","title":"Short Circuiting your DAG"},{"location":"examples/basic-04/","text":"","title":"Dynamically creating tasks"},{"location":"faq/faq/","text":"","title":"FAQ"},{"location":"getting-started/airflow-concepts/","text":"","title":"Airflow Concepts"},{"location":"getting-started/databricks-workflow-concepts/","text":"","title":"Databricks Workflows"},{"location":"getting-started/environment-variables/","text":"","title":"Environment Variables"},{"location":"getting-started/installation/","text":"","title":"Installation"},{"location":"getting-started/projects/","text":"","title":"Projects"},{"location":"getting-started/tasks/","text":"","title":"Tasks"},{"location":"getting-started/workflows/","text":"","title":"Workflows"},{"location":"guides/airflow-operators/","text":"","title":"Using Airflow Operators"},{"location":"guides/dag-to-workflows/","text":"","title":"Airflow DAGs to Workflows"},{"location":"guides/dev-loop/","text":"","title":"Development Loop"},{"location":"guides/dlt-pipelines/","text":"","title":"Creating DLT Pipelines"},{"location":"guides/setup/","text":"","title":"Setting up brickflow"},{"location":"guides/sql-warehouses/","text":"","title":"Working with SQL Warehouses"},{"location":"guides/submitting-sql-files/","text":"","title":"Submitting SQL Files"}]}